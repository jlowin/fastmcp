---
title: Testing your FastMCP Server
sidebarTitle: Testing
description: How to test your FastMCP server.
icon: vial
---

The best way to ensure a reliable and maintainable FastMCP Server is to test it! The FastMCP Client combined with Pytest provides a simple and powerful way to test your FastMCP servers.

## Prerequisites

Testing FastMCP servers requires `pytest-asyncio` to handle async test functions and fixtures. Install it as a development dependency:

```bash
pip install pytest-asyncio
```

We recommend configuring pytest to automatically handle async tests by setting the asyncio mode to `auto` in your `pyproject.toml`:

```toml
[tool.pytest.ini_options]
asyncio_mode = "auto"
```

This eliminates the need to decorate every async test with `@pytest.mark.asyncio`.

## Testing with Pytest Fixtures

Using Pytest Fixtures, you can wrap your FastMCP Server in a Client instance that makes interacting with your server fast and easy. This is especially useful when building your own MCP Servers and enables a tight development loop by allowing you to avoid using a separate tool like MCP Inspector during development:

```python
import pytest
from fastmcp.client import Client
from fastmcp.client.transports import FastMCPTransport

from my_project.main import mcp

@pytest.fixture
async def main_mcp_client():
    async with Client(transport=mcp) as mcp_client:
        yield mcp_client

async def test_list_tools(main_mcp_client: Client[FastMCPTransport]):
    list_tools = await main_mcp_client.list_tools()

    assert len(list_tools) == 5
```

We recommend the [inline-snapshot library](https://github.com/15r10nk/inline-snapshot) for asserting complex data structures coming from your MCP Server. This library allows you to write tests that are easy to read and understand, and are also easy to update when the data structure changes. 

```python
from inline_snapshot import snapshot

async def test_list_tools(main_mcp_client: Client[FastMCPTransport]):
    list_tools = await main_mcp_client.list_tools()

    assert list_tools == snapshot()
```

Simply run `pytest --inline-snapshot=fix,create` to fill in the `snapshot()` with actual data.

<Tip>
For values that change you can leverage the [dirty-equals](https://github.com/samuelcolvin/dirty-equals) library to perform flexible equality assertions on dynamic or non-deterministic values.
</Tip>

Using the pytest `parametrize` decorator, you can easily test your tools with a wide variety of inputs.

```python
import pytest
from my_project.main import mcp

from fastmcp.client import Client
from fastmcp.client.transports import FastMCPTransport
@pytest.fixture
async def main_mcp_client():
    async with Client(mcp) as client:
        yield client


@pytest.mark.parametrize(
    "first_number, second_number, expected",
    [
        (1, 2, 3),
        (2, 3, 5),
        (3, 4, 7),
    ],
)
async def test_add(
    first_number: int,
    second_number: int,
    expected: int,
    main_mcp_client: Client[FastMCPTransport],
):
    result = await main_mcp_client.call_tool(
        name="add", arguments={"x": first_number, "y": second_number}
    )
    assert result.data is not None
    assert isinstance(result.data, int)
    assert result.data == expected
```

<Tip>
The [FastMCP Repository contains thousands of tests](https://github.com/jlowin/fastmcp/tree/main/tests) for the FastMCP Client and Server. Everything from connecting to remote MCP servers, to testing tools, resources, and prompts is covered, take a look for inspiration!
</Tip>

## Testing with Postman

Postman now provides native support for the Model Context Protocol, allowing you to interactively test and debug your FastMCP servers through its visual interface. This is particularly useful for manual testing, exploring your server's capabilities, and validating behavior during development.

### Prerequisites

To test your FastMCP server with Postman, you'll need:

1. **A running FastMCP server over HTTP** - Postman connects to servers via HTTP transport. See the [HTTP Deployment guide](/deployment/http) for setup instructions.

2. **Postman desktop application** - MCP support is available in the Postman desktop app. [Download Postman](https://www.postman.com/downloads/) if you haven't already.

### Setting Up Postman

Deploy your FastMCP server with HTTP transport:

```python server.py
from fastmcp import FastMCP

mcp = FastMCP("My Server")

@mcp.tool
def process_data(input: str) -> str:
    """Process data on the server"""
    return f"Processed: {input}"

if __name__ == "__main__":
    mcp.run(transport="http", host="0.0.0.0", port=8000)
```

Start your server:
```bash
python server.py
```

Your server is now accessible at `http://localhost:8000/mcp`.

### Making MCP Requests

Postman's MCP request feature allows you to:

- **List available tools, resources, and prompts** - Discover what your server exposes
- **Call tools with arguments** - Test tool execution with different inputs
- **Read resources** - Verify resource content and templates
- **Execute prompts** - Test prompt responses
- **Debug server responses** - Inspect request/response details and error messages

In Postman, create a new MCP request and point it to your server's URL (`http://localhost:8000/mcp`). Use the Postman interface to interact with your server's capabilities.

For detailed instructions on using Postman's MCP features, see [Postman's MCP documentation](https://learning.postman.com/docs/postman-ai/mcp-requests/overview).

### When to Use Postman vs Pytest

**Use Postman when:**
- Exploring your server's capabilities interactively
- Manually testing specific scenarios during development
- Debugging unexpected behavior or error messages
- Demonstrating server functionality to team members
- Working on a server that's already deployed remotely

**Use Pytest when:**
- Building automated test suites for CI/CD pipelines
- Testing multiple scenarios with parameterized inputs
- Ensuring consistent behavior across code changes
- Writing regression tests for bug fixes
- Validating complex assertions on response data

Both approaches are complementary. Use Postman for interactive exploration and debugging, and Pytest for automated, repeatable testing as part of your development workflow.