---
title: Testing your FastMCP Server
sidebarTitle: Testing
description: How to test your FastMCP server.
icon: vial
---

The best way to ensure a reliable and maintainable FastMCP Server is to test it! The FastMCP Client combined with Pytest provides a simple and powerful way to test your FastMCP servers.

## Prerequisites

Testing FastMCP servers requires `pytest-asyncio` to handle async test functions and fixtures. Install it as a development dependency:

```bash
pip install pytest-asyncio
```

We recommend configuring pytest to automatically handle async tests by setting the asyncio mode to `auto` in your `pyproject.toml`:

```toml
[tool.pytest.ini_options]
asyncio_mode = "auto"
```

This eliminates the need to decorate every async test with `@pytest.mark.asyncio`.

## Testing with Pytest Fixtures

Using Pytest Fixtures, you can wrap your FastMCP Server in a Client instance that makes interacting with your server fast and easy. This is especially useful when building your own MCP Servers and enables a tight development loop by allowing you to avoid using a separate tool like MCP Inspector during development:

```python
import pytest
from fastmcp.client import Client
from fastmcp.client.transports import FastMCPTransport

from my_project.main import mcp

@pytest.fixture
async def main_mcp_client():
    async with Client(transport=mcp) as mcp_client:
        yield mcp_client

async def test_list_tools(main_mcp_client: Client[FastMCPTransport]):
    list_tools = await main_mcp_client.list_tools()

    assert len(list_tools) == 5
```

We recommend the [inline-snapshot library](https://github.com/15r10nk/inline-snapshot) for asserting complex data structures coming from your MCP Server. This library allows you to write tests that are easy to read and understand, and are also easy to update when the data structure changes. 

```python
from inline_snapshot import snapshot

async def test_list_tools(main_mcp_client: Client[FastMCPTransport]):
    list_tools = await main_mcp_client.list_tools()

    assert list_tools == snapshot()
```

Simply run `pytest --inline-snapshot=fix,create` to fill in the `snapshot()` with actual data.

<Tip>
For values that change you can leverage the [dirty-equals](https://github.com/samuelcolvin/dirty-equals) library to perform flexible equality assertions on dynamic or non-deterministic values.
</Tip>

Using the pytest `parametrize` decorator, you can easily test your tools with a wide variety of inputs.

```python
import pytest
from my_project.main import mcp

from fastmcp.client import Client
from fastmcp.client.transports import FastMCPTransport
@pytest.fixture
async def main_mcp_client():
    async with Client(mcp) as client:
        yield client


@pytest.mark.parametrize(
    "first_number, second_number, expected",
    [
        (1, 2, 3),
        (2, 3, 5),
        (3, 4, 7),
    ],
)
async def test_add(
    first_number: int,
    second_number: int,
    expected: int,
    main_mcp_client: Client[FastMCPTransport],
):
    result = await main_mcp_client.call_tool(
        name="add", arguments={"x": first_number, "y": second_number}
    )
    assert result.data is not None
    assert isinstance(result.data, int)
    assert result.data == expected
```

<Tip>
The [FastMCP Repository contains thousands of tests](https://github.com/jlowin/fastmcp/tree/main/tests) for the FastMCP Client and Server. Everything from connecting to remote MCP servers, to testing tools, resources, and prompts is covered, take a look for inspiration!
</Tip>

## Testing with Postman

Postman now provides native support for the Model Context Protocol, allowing you to interactively test and debug your FastMCP servers through its visual interface. This is particularly useful for manual testing, exploring your server's capabilities, and validating behavior during development.

### Prerequisites

To test your FastMCP server with Postman, you'll need:

1. **A running FastMCP server over HTTP** - Postman connects to servers via HTTP transport. See the [HTTP Deployment guide](/deployment/http) for setup instructions.

2. **Postman desktop application** - MCP support is available in the Postman desktop app. [Download Postman](https://www.postman.com/downloads/) if you haven't already.

### Setting Up Postman

Deploy your FastMCP server with HTTP transport:

```python server.py
from fastmcp import FastMCP

mcp = FastMCP("My Server")

@mcp.tool
def process_data(input: str) -> str:
    """Process data on the server"""
    return f"Processed: {input}"

if __name__ == "__main__":
    mcp.run(transport="http", host="0.0.0.0", port=8000)
```

Start your server:
```bash
python server.py
```

Your server is now accessible at `http://localhost:8000/mcp`.

### Making MCP Requests

Postman's MCP request feature allows you to:

- **List available tools, resources, and prompts** - Discover what your server exposes
- **Call tools with arguments** - Test tool execution with different inputs
- **Read resources** - Verify resource content and templates
- **Execute prompts** - Test prompt responses
- **Debug server responses** - Inspect request/response details and error messages

In Postman, create a new MCP request and point it to your server's URL (`http://localhost:8000/mcp`). Use the Postman interface to interact with your server's capabilities.

For detailed instructions on using Postman's MCP features, see [Postman's MCP documentation](https://learning.postman.com/docs/postman-ai/mcp-requests/overview).

### When to Use Postman vs Pytest

**Use Postman when:**
- Exploring your server's capabilities interactively
- Manually testing specific scenarios during development
- Debugging unexpected behavior or error messages
- Demonstrating server functionality to team members
- Working on a server that's already deployed remotely

**Use Pytest when:**
- Building automated test suites for CI/CD pipelines
- Testing multiple scenarios with parameterized inputs
- Ensuring consistent behavior across code changes
- Writing regression tests for bug fixes
- Validating complex assertions on response data

Both approaches are complementary. Use Postman for interactive exploration and debugging, and Pytest for automated, repeatable testing as part of your development workflow.

## Testing with MCPJam Inspector

MCPJam Inspector is a local-first developer tool that provides a visual interface for testing, debugging, and inspecting MCP servers. It functions like "Postman for MCP" and is particularly useful for exploring server capabilities, testing tools with different parameters, and debugging protocol-level interactions.

### Prerequisites

To test your FastMCP server with MCPJam Inspector, you'll need:

1. **A running FastMCP server** - MCPJam Inspector supports all transport protocols (STDIO, HTTP, and SSE). See the [HTTP Deployment guide](/deployment/http) for HTTP transport setup.

2. **MCPJam Inspector running locally** - The inspector runs as a local web application at `http://127.0.0.1:6274` in your browser. Visit [MCPJam](https://www.mcpjam.com/) to get started.

### Setting Up MCPJam Inspector

Deploy your FastMCP server with your preferred transport. For HTTP:

```python server.py
from fastmcp import FastMCP

mcp = FastMCP("My Server")

@mcp.tool
def process_data(input: str) -> str:
    """Process data on the server"""
    return f"Processed: {input}"

if __name__ == "__main__":
    mcp.run(transport="http", host="0.0.0.0", port=8000)
```

Start your server:
```bash
python server.py
```

Your server is now accessible at `http://localhost:8000/mcp`.

### Connecting to Your Server

In MCPJam Inspector:

1. Navigate to the local dashboard at `http://127.0.0.1:6274`
2. Click the "Add Server" button
3. Select your connection type (STDIO, HTTP, or SSE)
4. Enter your server name and connection details (URL, credentials if needed)
5. Confirm to establish the connection

For HTTP servers with authentication, include your credentials in the connection setup. MCPJam Inspector supports OAuth debugging for OAuth-protected servers.

### Testing Server Capabilities

MCPJam Inspector provides several testing features:

- **Tools Tab** - Browse available tools, fill in parameter values, execute calls, and review structured response data
- **Resources Tab** - Inspect and browse available resources and resource templates
- **Prompts Tab** - Test prompt templates with different inputs
- **LLM Playground** - Connect your server to real AI models (Claude, GPT, Ollama) and test full conversational flows
- **JSON-RPC Logs** - View real-time protocol messages between the inspector and your server for low-level debugging

The LLM Playground is particularly powerfulâ€”it lets you test how your MCP server behaves when integrated with actual language models, helping you validate tool descriptions, parameter schemas, and response formats in realistic scenarios.

### When to Use MCPJam Inspector vs Other Tools

**Use MCPJam Inspector when:**
- Testing protocol-level interactions and debugging JSON-RPC messages
- Validating server behavior across different transport protocols (STDIO, HTTP, SSE)
- Testing OAuth authentication flows and debugging authorization issues
- Exploring how your server integrates with different LLM models
- Working locally without deploying to a remote environment

**Use Postman when:**
- Testing remote HTTP servers that are already deployed
- Sharing test requests with team members via Postman collections
- Working in an environment where you're already using Postman for API testing

**Use Pytest when:**
- Building automated test suites for CI/CD pipelines
- Testing multiple scenarios with parameterized inputs
- Ensuring consistent behavior across code changes
- Writing regression tests for bug fixes

All three approaches are complementary. Use MCPJam Inspector for local, protocol-level testing and LLM integration validation; Postman for remote HTTP testing and collaboration; and Pytest for automated, repeatable testing in your development workflow.