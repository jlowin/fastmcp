---
title: Testing MCP Servers
sidebarTitle: Testing
description: Learn how to test your FastMCP servers effectively 
icon: vial
---


Testing your MCP servers thoroughly is essential for ensuring they work correctly when deployed. FastMCP makes this easy through a variety of testing patterns.

## In-Memory Testing

The most efficient way to test an MCP server is to pass your FastMCP server instance directly to a Client. This enables in-memory testing without having to start a separate server process, which is particularly useful because managing an MCP server programmatically can be challenging.

Here is an example of using a `Client` to test a server with pytest:

```python
import pytest
from fastmcp import FastMCP, Client

@pytest.fixture
def mcp_server():
    server = FastMCP("TestServer")
    
    @server.tool()
    def greet(name: str) -> str:
        return f"Hello, {name}!"
        
    return server

async def test_tool_functionality(mcp_server):
    # Pass the server directly to the Client constructor
    async with Client(mcp_server) as client:
        result = await client.call_tool("greet", {"name": "World"})
        assert result[0].text == "Hello, World!"
```

This pattern creates a direct connection between the client and server, allowing you to test your server's functionality efficiently.



### Stdio 

By default, `FastMCPTransport` creates a direct connection to the server using the `stdio` transport. This is the most efficient way to test your server's functionality.

```python
from fastmcp.client.transports import FastMCPTransport

async def test_stdio_transport(mcp_server):
    transport = FastMCPTransport(mcp_server, transport="stdio")
    async with Client(transport) as client:
        result = await client.call_tool("greet", {"name": "World"})
        assert result[0].text == "Hello, World!"
```

### Streamable HTTP

For testing HTTP-specific behavior, you can simulate a `streamable-http` connection:

```python
async def test_http_transport(mcp_server):
    transport = FastMCPTransport(mcp_server, transport="streamable-http")
    async with Client(transport) as client:
        result = await client.call_tool("greet", {"name": "World"})
        assert result[0].text == "Hello, World!"
```

<Note>
When using `transport="streamable-http"`, SSE-based streaming features like progress reporting and sampling callbacks are not supported due to in-memory ASGI transport limitations. Use stdio mode for testing streaming capabilities.
</Note>

## Integration Testing

For full integration tests that verify your server works correctly over real HTTP connections, use `run_server_in_process` from `fastmcp.utilities.tests`. You can use this to test both SSE and streamable HTTP transports:

```python
import sys
import pytest
import uvicorn
from fastmcp import FastMCP, Client
from fastmcp.utilities.tests import run_server_in_process

def create_server():
    server = FastMCP("IntegrationServer")
    
    @server.tool()
    def greet(name: str) -> str:
        return f"Hello, {name}!"
    
    return server

def run_server(host: str, port: int) -> None:
    try:
        app = create_server().http_app(transport="streamable-http")
        server = uvicorn.Server(
            config=uvicorn.Config(app=app, host=host, port=port, log_level="error")
        )
        server.run()
    except Exception as e:
        print(f"Server error: {e}")
        sys.exit(1)
    sys.exit(0)

@pytest.fixture(scope="module")
def integration_server():
    with run_server_in_process(run_server) as url:
        yield f"{url}/mcp"

async def test_integration(integration_server):
    """Test against a real HTTP server."""
    async with Client(integration_server) as client:
        result = await client.call_tool("greet", {"name": "Integration"})
        assert result[0].text == "Hello, Integration!"
```

This approach starts your FastMCP server in a separate process and provides a real URL for testing, making it ideal for verifying HTTP transport behavior, authentication, and other deployment-specific functionality.
