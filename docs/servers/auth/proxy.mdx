---
title: OAuth Proxy
sidebarTitle: OAuth Proxy
description: Proxy OAuth flows to upstream providers while handling client registration locally.
icon: arrow-right-to-bracket
tag: NEW
---

import { VersionBadge } from "/snippets/version-badge.mdx"

<VersionBadge version="2.11.0" />

<Tip>
OAuth proxy authentication is only relevant for HTTP-based transports and requires an upstream OAuth provider.
</Tip>

The `OAuthProxy` provider lets you integrate FastMCP with existing OAuth providers (like Auth0, GitHub, WorkOS, or corporate identity systems) without changing your upstream configuration. Instead of creating new OAuth applications, you reuse existing ones by having FastMCP act as a transparent proxy.

## Basic Usage

Here's how to set up OAuth proxy with an upstream provider that issues JWT tokens:

```python
from fastmcp import FastMCP
from fastmcp.server.auth.providers.proxy import OAuthProxy
from fastmcp.server.auth.verifiers import JWTVerifier

# First, configure how to validate tokens from your upstream provider
token_verifier = JWTVerifier(
    jwks_uri="https://your-auth-provider.com/.well-known/jwks.json",
    issuer=None  # Skip issuer validation in proxy mode
)

# Then, configure the proxy with your existing OAuth app credentials
proxy = OAuthProxy(
    upstream_authorization_endpoint="https://your-auth-provider.com/oauth/authorize",
    upstream_token_endpoint="https://your-auth-provider.com/oauth/token",
    upstream_client_id="your-existing-app-client-id",
    upstream_client_secret="your-existing-app-secret",
    token_verifier=token_verifier,
    issuer_url="https://your-fastmcp-server.com"
)

# Use the proxy with FastMCP
mcp = FastMCP("My Secure Server", auth=proxy)

@mcp.tool
def protected_action() -> str:
    """This tool requires authentication via your upstream OAuth provider."""
    return "You're authenticated!"
```

When clients connect to your FastMCP server:

1. **They register with FastMCP** (which returns your upstream app credentials)  
2. **They get redirected to your upstream provider** for authentication
3. **Your upstream provider handles login** (just like normal)
4. **FastMCP receives and validates tokens** using the configured verifier

## What You Need

To use `OAuthProxy`, you need:

1. **An existing OAuth application** registered with your provider (Auth0, GitHub, etc.)
2. **The OAuth endpoints** from your provider
3. **A way to validate tokens** - either JWT verification or token introspection

## Configuration Parameters

<Card icon="code" title="OAuthProxy Configuration">
<ParamField body="upstream_authorization_endpoint" type="str" required>
  Where users go to log in (e.g., `https://auth.company.com/oauth/authorize`)
</ParamField>

<ParamField body="upstream_token_endpoint" type="str" required>
  Where authorization codes get exchanged for tokens (e.g., `https://auth.company.com/oauth/token`)
</ParamField>

<ParamField body="upstream_client_id" type="str" required>
  Your existing OAuth app's client ID
</ParamField>

<ParamField body="upstream_client_secret" type="str" required>
  Your existing OAuth app's client secret
</ParamField>

<ParamField body="token_verifier" type="TokenVerifier" required>
  How to validate tokens (JWT, introspection, or custom)
</ParamField>

<ParamField body="issuer_url" type="str" required>
  Your FastMCP server's public URL
</ParamField>

<ParamField body="upstream_revocation_endpoint" type="str">
  Optional: where to revoke tokens
</ParamField>
</Card>

## Token Validation Options

The proxy needs to know how to validate tokens from your upstream provider. You have three options:

<Tabs>
<Tab title="JWT Verification">
Most OAuth providers (Auth0, WorkOS, Azure AD) issue JWT tokens. Use this when your provider exposes a JWKS endpoint:

```python
from fastmcp.server.auth.verifiers import JWTVerifier

token_verifier = JWTVerifier(
    jwks_uri="https://your-provider.com/.well-known/jwks.json",
    issuer=None,  # Skip issuer validation in proxy mode
    required_scopes=["read", "write"]  # Optional: require specific scopes
)
```
</Tab>

<Tab title="Token Introspection">
Some providers support RFC 7662 token introspection, which validates tokens by calling the provider's API:

```python
from fastmcp.server.auth.verifiers import IntrospectionTokenVerifier

token_verifier = IntrospectionTokenVerifier(
    introspection_endpoint="https://your-provider.com/oauth/introspect",
    server_url="https://your-fastmcp-server.com",
    client_id="your-resource-server-client-id",
    client_secret="your-resource-server-secret"
)
```
</Tab>

<Tab title="Custom Validation">
For providers with unique APIs (like GitHub), create a custom verifier:

```python
from fastmcp.server.auth.auth import TokenVerifier
from mcp.server.auth.provider import AccessToken
import httpx

class GitHubTokenVerifier(TokenVerifier):
    async def verify_token(self, token: str) -> AccessToken | None:
        async with httpx.AsyncClient() as client:
            response = await client.get(
                "https://api.github.com/user",
                headers={"Authorization": f"Bearer {token}"}
            )
            
            if response.status_code == 200:
                user = response.json()
                return AccessToken(
                    token=token,
                    client_id=str(user["id"]),
                    scopes=["user"],
                    expires_at=None
                )
        return None
```
</Tab>
</Tabs>
