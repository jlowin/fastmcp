---
title: Bearer Token Authentication
sidebarTitle: Bearer Auth
description: Secure your FastMCP server's HTTP endpoints by validating JWT Bearer tokens.
icon: key
tag: NEW
---

import { VersionBadge } from "/snippets/version-badge.mdx"

<VersionBadge version="2.6.0" />
<Tip>
Authentication and authorization are only relevant for HTTP-based transports.
</Tip>

<Note>
The [MCP specification](https://modelcontextprotocol.io/specification/2025-03-26/basic/authorization) requires servers to implement full OAuth 2.1 authorization flows with dynamic client registration, server metadata discovery, and complete token endpoints. FastMCP's Bearer Token authentication provides a simpler, more practical alternative by directly validating pre-issued JWT tokensâ€”ideal for service-to-service communication and programmatic environments where full OAuth flows may be impractical, and in accordance with how the MCP ecosystem is pragmatically evolving. However, please note that since it doesn't implement the full OAuth 2.1 flow, this implementation does not strictly comply with the MCP specification.
</Note>

Bearer Token authentication is a common way to secure HTTP-based APIs. In this model, the client sends a token (usually a JSON Web Token or JWT) in the `Authorization` header with the "Bearer" scheme. The server then validates this token to grant or deny access.

FastMCP supports Bearer Token authentication for its HTTP-based transports (`http` and `sse`), allowing you to protect your server from unauthorized access.

## Authentication Strategy

FastMCP uses **asymmetric encryption** for token validation, which provides a clean security separation between token issuers and FastMCP servers. This approach means:

- **No shared secrets**: Your FastMCP server never needs access to private keys or client secrets
- **Public key verification**: The server only needs a public key (or JWKS endpoint) to verify token signatures
- **Secure token issuance**: Tokens are signed by an external service using a private key that never leaves the issuer
- **Scalable architecture**: Multiple FastMCP servers can validate tokens without coordinating secrets

This design allows you to integrate FastMCP servers into existing authentication infrastructures without compromising security boundaries.

## Configuration

To enable Bearer Token validation on your FastMCP server, use the `BearerAuthProvider` class. This provider validates incoming JWTs by verifying signatures, checking expiration, and optionally validating claims.

<Warning>
The `BearerAuthProvider` validates tokens; it does **not** issue them (or implement any part of an OAuth flow). You'll need to generate tokens separately, either using FastMCP utilities or an external Identity Provider (IdP) or OAuth 2.1 Authorization Server.
</Warning>

### Basic Setup

To configure bearer token authentication, instantiate a `BearerAuthProvider` instance and pass it to the `auth` parameter of the `FastMCP` instance.

The `BearerAuthProvider` requires either a static public key or a JWKS URI (but not both!) in order to verify the token's signature. All other parameters are optional -- if they are provided, they will be used as additional validation criteria.

```python {2, 10}
from fastmcp import FastMCP
from fastmcp.server.auth import BearerAuthProvider

auth = BearerAuthProvider(
    jwks_uri="https://my-identity-provider.com/.well-known/jwks.json",
    issuer="https://my-identity-provider.com/",
    algorithm="RS512",
    audience="my-mcp-server"
)

mcp = FastMCP(name="My MCP Server", auth=auth)
```

### Configuration Parameters

<Card icon="code" title="BearerAuthProvider Configuration">
<ParamField body="public_key" type="str">
  RSA public key in PEM format for static key validation. Required if `jwks_uri` is not provided
</ParamField>

<ParamField body="jwks_uri" type="str">
  URL for JSON Web Key Set endpoint. Required if `public_key` is not provided
</ParamField>

<ParamField body="issuer" type="str | None">
  Expected JWT `iss` claim value
</ParamField>

<ParamField body="algorithm" type="str | None">
  Algorithm for decoding JWT token. Defaults to 'RS256'
</ParamField>

<ParamField body="audience" type="str | None">
  Expected JWT `aud` claim value
</ParamField>

<ParamField body="required_scopes" type="list[str] | None">
  Global scopes required for all requests
</ParamField>
</Card>

#### Public Key

If you have a public key in PEM format, you can provide it to the `BearerAuthProvider` as a string.

```python {12}
from fastmcp.server.auth import BearerAuthProvider
import inspect

public_key_pem = inspect.cleandoc(
    """
    -----BEGIN PUBLIC KEY-----
    MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAy...
    -----END PUBLIC KEY-----
    """
)

auth = BearerAuthProvider(public_key=public_key_pem)
```

#### JWKS URI

```python
provider = BearerAuthProvider(
    jwks_uri="https://idp.example.com/.well-known/jwks.json"
)
```

<Note>
JWKS is recommended for production as it supports automatic key rotation and multiple signing keys.
</Note>

## Generating Tokens

For development and testing, FastMCP provides the `RSAKeyPair` utility class to generate tokens without needing an external OAuth provider.

<Warning>
The `RSAKeyPair` utility is intended for development and testing only. For production, use a proper OAuth 2.1 Authorization Server or Identity Provider.
</Warning>
### Basic Token Generation

```python
from fastmcp import FastMCP
from fastmcp.server.auth import BearerAuthProvider
from fastmcp.server.auth.providers.bearer import RSAKeyPair

# Generate a new key pair
key_pair = RSAKeyPair.generate()

# Configure the auth provider with the public key
auth = BearerAuthProvider(
    public_key=key_pair.public_key,
    issuer="https://dev.example.com",
    audience="my-dev-server"
)

mcp = FastMCP(name="Development Server", auth=auth)

# Generate a token for testing
token = key_pair.create_token(
    subject="dev-user",
    issuer="https://dev.example.com",
    audience="my-dev-server",
    scopes=["read", "write"]
)

print(f"Test token: {token}")
```

### Token Creation Parameters

The `create_token()` method accepts these parameters:

<Card icon="code" title="create_token() Parameters">
<ParamField body="subject" type="str" default="fastmcp-user">
  JWT subject claim (usually user ID)
</ParamField>

<ParamField body="issuer" type="str" default="https://fastmcp.example.com">
  JWT issuer claim
</ParamField>

<ParamField body="audience" type="str | None">
  JWT audience claim
</ParamField>

<ParamField body="scopes" type="list[str] | None">
  OAuth scopes to include
</ParamField>

<ParamField body="expires_in_seconds" type="int" default="3600">
  Token expiration time in seconds
</ParamField>

<ParamField body="additional_claims" type="dict | None">
  Extra claims to include in the token
</ParamField>

<ParamField body="kid" type="str | None">
  Key ID for JWKS lookup
</ParamField>
</Card>


## Accessing Token Claims

Once authenticated, your tools, resources, or prompts can access token information using the `get_access_token()` dependency function:

```python
from fastmcp import FastMCP, Context, ToolError
from fastmcp.server.dependencies import get_access_token, AccessToken

@mcp.tool
async def get_my_data(ctx: Context) -> dict:
    access_token: AccessToken = get_access_token()
    
    user_id = access_token.client_id  # From JWT 'sub' or 'client_id' claim
    user_scopes = access_token.scopes
    
    if "data:read_sensitive" not in user_scopes:
        raise ToolError("Insufficient permissions: 'data:read_sensitive' scope required.")
    
    return {
        "user": user_id,
        "sensitive_data": f"Private data for {user_id}",
        "granted_scopes": user_scopes
    }
```

### AccessToken Properties

<Card icon="code" title="AccessToken Properties">
<ParamField body="token" type="str">
  The raw JWT string
</ParamField>

<ParamField body="client_id" type="str">
  Authenticated principal identifier
</ParamField>

<ParamField body="scopes" type="list[str]">
  Granted scopes
</ParamField>

<ParamField body="expires_at" type="datetime | None">
  Token expiration timestamp
</ParamField>
</Card>

## Scope-Based Authorization

FastMCP supports scope-based authorization, allowing you to restrict access to specific tools, resources, or prompts based on the scopes present in the access token. This provides fine-grained control over what authenticated users can access.

### Tool Scope Validation

You can require specific scopes for tools using the `required_scope` parameter:

```python
from fastmcp import FastMCP
from fastmcp.server.auth import BearerAuthProvider

mcp = FastMCP(name="My Server", auth=auth)

# Require specific scope for this tool
@mcp.tool(required_scope="admin:write")
async def admin_action() -> str:
    return "Admin action completed"

# Default scope is the tool name
@mcp.tool(required_scope="user_data")  # or omit for default
async def user_data() -> str:
    return "User data retrieved"

# No scope required (accessible to all authenticated users)
@mcp.tool
async def public_tool() -> str:
    return "Public data"
```

### Default Scope Behavior

When `required_scope` is not specified, FastMCP uses the tool name as the default required scope:

```python
# These two are equivalent:
@mcp.tool
async def get_user_profile() -> str:
    return "Profile data"

@mcp.tool(required_scope="get_user_profile")
async def get_user_profile() -> str:
    return "Profile data"
```

### Error Handling

FastMCP provides distinct error types for authentication vs authorization failures:

```python
from fastmcp.exceptions import AuthenticationError, AuthorizationError

@mcp.tool
async def sensitive_operation() -> str:
    # Manual scope checking (usually not needed)
    access_token = get_access_token()
    
    if not access_token:
        raise AuthenticationError("No access token provided")
    
    if "sensitive:read" not in access_token.scopes:
        raise AuthorizationError("Insufficient permissions: 'sensitive:read' scope required")
    
    return "Sensitive data"
```

### Client Error Handling

Clients can distinguish between authentication and authorization errors:

```python
from fastmcp.client import FastMCPClient
from fastmcp.exceptions import AuthenticationError, AuthorizationError

async def call_protected_tool():
    try:
        result = await client.call_tool("admin_action")
        return result
    except AuthenticationError as e:
        # Token is invalid, expired, or missing
        print(f"Authentication failed: {e}")
        # Handle by refreshing token or re-authenticating
    except AuthorizationError as e:
        # Token is valid but lacks required scopes
        print(f"Authorization failed: {e}")
        # Handle by requesting additional scopes or showing permission denied
```

### Debugging Scope Validation

If scope validation isn't working as expected, you can create a debugging script to troubleshoot:

```python
import logging
from fastmcp import FastMCP
from fastmcp.server.auth import BearerAuthProvider
from fastmcp.server.auth.providers.bearer import RSAKeyPair

# Enable debug logging
logging.basicConfig(level=logging.DEBUG)

# Create key pair for testing
key_pair = RSAKeyPair.generate()

# Configure auth provider
auth = BearerAuthProvider(
    public_key=key_pair.public_key,
    issuer="https://debug.example.com",
    audience="debug-server"
)

mcp = FastMCP(name="Debug Server", auth=auth)

@mcp.tool(required_scope="admin:write")
async def admin_tool() -> str:
    return "Admin operation completed"

@mcp.tool()  # Uses default scope: "user_tool"
async def user_tool() -> str:
    return "User operation completed"

# Test tokens with different scopes
test_tokens = {
    "empty_scopes": key_pair.create_token(
        subject="test-user",
        issuer="https://debug.example.com",
        audience="debug-server",
        scopes=[]  # Empty scopes
    ),
    "admin_token": key_pair.create_token(
        subject="admin-user",
        issuer="https://debug.example.com",
        audience="debug-server",
        scopes=["admin:write", "admin:read"]
    ),
    "user_token": key_pair.create_token(
        subject="regular-user",
        issuer="https://debug.example.com",
        audience="debug-server",
        scopes=["user_tool", "profile:read"]
    )
}

# Print tokens for testing
for token_type, token in test_tokens.items():
    print(f"{token_type}: {token}")
```

### Testing with cURL

You can test scope validation using cURL:

```bash
# Test with empty scopes (should fail)
curl -X POST http://localhost:8000/mcp/v1/tools/call \
  -H "Authorization: Bearer $EMPTY_SCOPE_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"name": "admin_tool", "arguments": {}}'

# Test with admin scope (should succeed)
curl -X POST http://localhost:8000/mcp/v1/tools/call \
  -H "Authorization: Bearer $ADMIN_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"name": "admin_tool", "arguments": {}}'
```

### Common Issues

<Warning>
**Scope validation only works with HTTP transports** (`http` and `sse`). It does not apply to `stdio` transport.
</Warning>

1. **No error when scopes are missing**: Ensure `ErrorHandlingMiddleware` is included in your server configuration
2. **Scope validation not triggered**: Verify that `auth` is properly configured on your FastMCP instance
3. **Default scope not working**: Check that tool names match expected scope names
4. **Token parsing issues**: Verify token format and signature validation

### Advanced Debugging

For detailed debugging, you can monkey-patch the validation method:

```python
import logging
from fastmcp.server.server import FastMCPServer

# Store original method
original_validate = FastMCPServer._validate_tool_scope

def debug_validate_tool_scope(self, tool_name: str, required_scope: str | None) -> None:
    logger = logging.getLogger(__name__)
    logger.debug(f"=== SCOPE VALIDATION DEBUG ===")
    logger.debug(f"Tool name: {tool_name}")
    logger.debug(f"Required scope: {required_scope}")
    logger.debug(f"Auth provider: {self.auth}")
    
    try:
        access_token = self.get_access_token()
        logger.debug(f"Access token: {access_token}")
        if access_token:
            logger.debug(f"Token scopes: {access_token.scopes}")
        
        # Call original method
        result = original_validate(self, tool_name, required_scope)
        logger.debug(f"Validation result: SUCCESS")
        return result
    except Exception as e:
        logger.debug(f"Validation result: FAILED - {e}")
        raise

# Apply monkey patch
FastMCPServer._validate_tool_scope = debug_validate_tool_scope
```

This debugging approach helps identify issues with token parsing, scope extraction, or validation logic.

