---
title: Authorization
sidebarTitle: Authorization
description: Control access to tools using callable-based authorization checks that filter visibility and enforce permissions.
icon: shield-halved
---

import { VersionBadge } from "/snippets/version-badge.mdx"

<VersionBadge version="3.0.0" />

Authorization controls what authenticated users can do with your FastMCP server. While [authentication](/servers/auth/authentication) verifies identity (who you are), authorization determines access (what you can do). FastMCP provides a callable-based authorization system that works at both the tool level and globally via middleware.

The authorization model centers on a simple concept: callable functions that receive context about the current request and return `True` to allow access or `False` to deny it. Multiple checks combine with AND logic, meaning all checks must pass for access to be granted.

<Note>
Authorization relies on OAuth tokens which are only available with HTTP transports (SSE, Streamable HTTP). In STDIO mode, there's no OAuth mechanism, so `get_access_token()` returns `None`. Tools with auth checks like `require_auth` will be hidden from STDIO clients.
</Note>

## Auth Checks

An auth check is any callable that accepts an `AuthContext` and returns a boolean. The `AuthContext` provides access to the current token (if any) and the tool being accessed.

```python
from fastmcp.server.auth import AuthContext

def my_custom_check(ctx: AuthContext) -> bool:
    # ctx.token is AccessToken | None
    # ctx.tool is the Tool being accessed
    return ctx.token is not None and "special" in ctx.token.scopes
```

FastMCP provides three built-in auth checks that cover common authorization patterns.

### require_auth

The simplest check verifies that any valid authentication token is present. Unauthenticated requests are denied.

```python
from fastmcp import FastMCP
from fastmcp.server.auth import require_auth

mcp = FastMCP("Protected Server")

@mcp.tool(auth=require_auth)
def protected_operation() -> str:
    """Only accessible to authenticated users."""
    return "Success"
```

### require_scopes

For scope-based authorization, `require_scopes` checks that the token contains all specified OAuth scopes. When multiple scopes are provided, all must be present (AND logic).

```python
from fastmcp import FastMCP
from fastmcp.server.auth import require_scopes

mcp = FastMCP("Scoped Server")

@mcp.tool(auth=require_scopes("admin"))
def admin_operation() -> str:
    """Requires the 'admin' scope."""
    return "Admin action completed"

@mcp.tool(auth=require_scopes("read", "write"))
def read_write_operation() -> str:
    """Requires both 'read' AND 'write' scopes."""
    return "Read/write action completed"
```

### restrict_tag

Tag-based restrictions apply scope requirements conditionally. If a tool has the specified tag, the token must have the required scopes. Tools without the tag are unaffected.

```python
from fastmcp import FastMCP
from fastmcp.server.auth import restrict_tag
from fastmcp.server.middleware import AuthMiddleware

mcp = FastMCP(
    "Tagged Server",
    middleware=[
        AuthMiddleware(auth=restrict_tag("admin", scopes=["admin"]))
    ]
)

@mcp.tool(tags={"admin"})
def admin_tool() -> str:
    """Tagged 'admin', so requires 'admin' scope."""
    return "Admin only"

@mcp.tool(tags={"public"})
def public_tool() -> str:
    """Not tagged 'admin', so no scope required by the restriction."""
    return "Anyone can access"
```

## Combining Checks

Multiple auth checks can be combined by passing a list. All checks must pass for authorization to succeed (AND logic).

```python
from fastmcp import FastMCP
from fastmcp.server.auth import require_auth, require_scopes

mcp = FastMCP("Combined Auth Server")

@mcp.tool(auth=[require_auth, require_scopes("admin")])
def secure_admin_action() -> str:
    """Requires authentication AND the 'admin' scope."""
    return "Secure admin action"
```

## Custom Auth Checks

Any callable that accepts `AuthContext` and returns `bool` can serve as an auth check. This enables authorization logic based on token claims, tool metadata, or external systems.

```python
from fastmcp import FastMCP
from fastmcp.server.auth import AuthContext

mcp = FastMCP("Custom Auth Server")

def require_premium_user(ctx: AuthContext) -> bool:
    """Check for premium user status in token claims."""
    if ctx.token is None:
        return False
    return ctx.token.claims.get("premium", False) is True

def require_access_level(minimum_level: int):
    """Factory function for level-based authorization."""
    def check(ctx: AuthContext) -> bool:
        if ctx.token is None:
            return False
        user_level = ctx.token.claims.get("level", 0)
        return user_level >= minimum_level
    return check

@mcp.tool(auth=require_premium_user)
def premium_feature() -> str:
    """Only for premium users."""
    return "Premium content"

@mcp.tool(auth=require_access_level(5))
def advanced_feature() -> str:
    """Requires access level 5 or higher."""
    return "Advanced feature"
```

Lambda functions work for simple inline checks.

```python
from fastmcp import FastMCP

mcp = FastMCP("Lambda Auth Server")

@mcp.tool(auth=lambda ctx: ctx.token and ctx.token.claims.get("level", 0) >= 5)
def level_restricted_tool() -> str:
    """Requires level 5+ in token claims."""
    return "High level access granted"
```

### Exception Handling in Auth Checks

Auth checks can raise exceptions for explicit denial with custom messages:

- **`AuthorizationError`**: Propagates with its custom message, useful for explaining why access was denied
- **Other exceptions**: Masked for security (logged internally, treated as denial)

```python
from fastmcp import FastMCP
from fastmcp.server.auth import AuthContext
from fastmcp.exceptions import AuthorizationError

mcp = FastMCP("Exception Auth Server")

def require_verified_email(ctx: AuthContext) -> bool:
    """Require verified email with explicit denial message."""
    if ctx.token is None:
        raise AuthorizationError("Authentication required")
    if not ctx.token.claims.get("email_verified"):
        raise AuthorizationError("Email verification required to access this tool")
    return True

@mcp.tool(auth=require_verified_email)
def sensitive_operation() -> str:
    """Only accessible to users with verified email."""
    return "Operation completed"
```

This pattern is useful when you want to provide actionable feedback to clients about why authorization failed.

## Tool-Level Authorization

The `auth` parameter on `@mcp.tool` controls visibility of individual tools. When a tool has auth checks that fail for the current request, it is hidden from `list_tools` responses. The tool simply doesn't appear in the available tools list.

```python
from fastmcp import FastMCP
from fastmcp.server.auth import require_auth, require_scopes

mcp = FastMCP("Tool Auth Server")

@mcp.tool
def public_tool() -> str:
    """Visible to everyone."""
    return "Public"

@mcp.tool(auth=require_auth)
def authenticated_tool() -> str:
    """Only visible to authenticated users."""
    return "Authenticated"

@mcp.tool(auth=require_scopes("admin"))
def admin_tool() -> str:
    """Only visible to users with 'admin' scope."""
    return "Admin"
```

An unauthenticated client sees only `public_tool`. An authenticated client without the "admin" scope sees `public_tool` and `authenticated_tool`. An authenticated client with the "admin" scope sees all three tools.

<Warning>
Tool-level `auth` only controls visibility in `list_tools`. It does not block direct tool calls. If a client knows a tool name, they can attempt to call it directly. Use `AuthMiddleware` to enforce authorization on tool execution.
</Warning>

## AuthMiddleware

For server-wide authorization enforcement, use `AuthMiddleware`. This middleware applies auth checks globally to all tools and provides two critical functions: filtering `list_tools` responses and enforcing authorization on `call_tool` requests.

```python
from fastmcp import FastMCP
from fastmcp.server.auth import require_auth
from fastmcp.server.middleware import AuthMiddleware

mcp = FastMCP(
    "Enforced Auth Server",
    middleware=[AuthMiddleware(auth=require_auth)]
)

@mcp.tool
def any_tool() -> str:
    """Requires authentication to see AND call."""
    return "Protected"
```

### Filtering vs Enforcement

Understanding the difference between tool-level auth and `AuthMiddleware` is important for building secure servers:

| Behavior | Tool-level `auth` | `AuthMiddleware` |
|----------|-------------------|------------------|
| Filters `list_tools` | Yes | Yes |
| Blocks `call_tool` | No | Yes (raises `AuthorizationError`) |

Tool-level auth is useful for hiding tools from unauthorized users while still allowing advanced clients to call them if needed. `AuthMiddleware` provides complete enforcement by raising `AuthorizationError` when unauthorized requests attempt to execute tools.

### Tag-Based Global Authorization

A common pattern uses `restrict_tag` with `AuthMiddleware` to apply scope requirements based on tool tags.

```python
from fastmcp import FastMCP
from fastmcp.server.auth import restrict_tag
from fastmcp.server.middleware import AuthMiddleware

mcp = FastMCP(
    "Tag-Based Auth Server",
    middleware=[
        AuthMiddleware(auth=restrict_tag("admin", scopes=["admin"])),
        AuthMiddleware(auth=restrict_tag("write", scopes=["write"])),
    ]
)

@mcp.tool(tags={"admin"})
def delete_all_data() -> str:
    """Requires 'admin' scope."""
    return "Deleted"

@mcp.tool(tags={"write"})
def update_record(id: str, data: str) -> str:
    """Requires 'write' scope."""
    return f"Updated {id}"

@mcp.tool
def read_record(id: str) -> str:
    """No tag restrictions, accessible to all authenticated users."""
    return f"Record {id}"
```

## Accessing Tokens in Tools

Tools can access the current authentication token using `get_access_token()` from `fastmcp.server.dependencies`. This enables tools to make decisions based on user identity or permissions beyond simple authorization checks.

```python
from fastmcp import FastMCP
from fastmcp.server.dependencies import get_access_token

mcp = FastMCP("Token Access Server")

@mcp.tool
def personalized_greeting() -> str:
    """Greet the user based on their token claims."""
    token = get_access_token()

    if token is None:
        return "Hello, guest!"

    name = token.claims.get("name", "user")
    return f"Hello, {name}!"

@mcp.tool
def user_dashboard() -> dict:
    """Return user-specific data based on token."""
    token = get_access_token()

    if token is None:
        return {"error": "Not authenticated"}

    return {
        "client_id": token.client_id,
        "scopes": token.scopes,
        "claims": token.claims,
    }
```

## AccessToken

The `AccessToken` object contains information extracted from the OAuth token.

| Property | Type | Description |
|----------|------|-------------|
| `token` | `str` | The raw token string |
| `client_id` | `str \| None` | OAuth client identifier |
| `scopes` | `list[str]` | Granted OAuth scopes |
| `expires_at` | `datetime \| None` | Token expiration time |
| `claims` | `dict[str, Any]` | All JWT claims or custom token data |

The `claims` dictionary contains the full decoded token payload for JWT tokens, enabling authorization decisions based on any claim present in the token.

## AuthContext

The `AuthContext` dataclass is passed to all auth check functions.

| Property | Type | Description |
|----------|------|-------------|
| `token` | `AccessToken \| None` | Current access token, or `None` if unauthenticated |
| `tool` | `Tool` | The tool being accessed |

Access to the tool object enables authorization decisions based on tool metadata like tags, name, or custom properties.

```python
from fastmcp.server.auth import AuthContext

def require_matching_tag(ctx: AuthContext) -> bool:
    """Require a scope matching each of the tool's tags."""
    if ctx.token is None:
        return False
    user_scopes = set(ctx.token.scopes)
    return ctx.tool.tags.issubset(user_scopes)
```

## Type Reference

All authorization types are exported from `fastmcp.server.auth`:

```python
from fastmcp.server.auth import (
    AccessToken,       # Token with .token, .client_id, .scopes, .expires_at, .claims
    AuthContext,       # Context with .token, .tool
    AuthCheck,         # Type alias: Callable[[AuthContext], bool]
    require_auth,      # Built-in: requires any valid token
    require_scopes,    # Built-in: requires specific scopes
    restrict_tag,      # Built-in: tag-based scope requirements
    run_auth_checks,   # Utility: run checks with AND logic
)
```

The `AuthMiddleware` is exported from `fastmcp.server.middleware`:

```python
from fastmcp.server.middleware import AuthMiddleware
```
