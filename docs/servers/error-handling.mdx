---
title: Error Handling
sidebarTitle: Error Handling
description: How FastMCP handles errors and provides actionable feedback to LLMs.
icon: shield-exclamation
---

import { VersionBadge } from '/snippets/version-badge.mdx'

<VersionBadge version="3.1.0" />

FastMCP provides intelligent error handling that balances security (hiding internal details) with usefulness (giving LLMs actionable feedback). This page explains how error handling works and how to customize it.

## Built-in Actionable Error Handling

FastMCP automatically converts certain "actionable" errors into helpful messages that LLMs can understand and act on—even when error masking is enabled. These are errors where the LLM can take meaningful action:

| Error Type | Message Sent to LLM |
|-----------|---------------------|
| HTTP 429 (Rate Limited) | "Rate limited by upstream API, please retry later" |
| Request Timeout | "Upstream request timed out, please retry" |

These messages pass through regardless of the `mask_error_details` setting because they represent actionable guidance, not internal implementation details.

## Error Masking

By default, FastMCP passes error details through to clients. In production, you may want to hide internal error details:

```python
from fastmcp import FastMCP

# Enable error masking for production
mcp = FastMCP("MyServer", mask_error_details=True)
```

With masking enabled:
- **Actionable errors** (429, timeouts) still show helpful messages
- **Other errors** show generic messages like "Error calling tool 'my_tool'"
- **ToolError exceptions** you raise explicitly always pass through unchanged

<Tip>
Use `ToolError` when you want to send a specific message to the LLM:

```python
from fastmcp.exceptions import ToolError

@mcp.tool
async def fetch_user(user_id: str) -> dict:
    if not user_id.isdigit():
        raise ToolError("User ID must be a number")
    # ... rest of implementation
```
</Tip>

## Optional: HTTP Error Decorator

For tools that make HTTP requests and need granular error handling beyond the built-in actionable errors, FastMCP provides an optional `@handle_http_errors()` decorator:

```python
from fastmcp import FastMCP
from fastmcp.error_handling import handle_http_errors
import httpx

mcp = FastMCP("MyServer")

@mcp.tool
@handle_http_errors()
async def fetch_user(username: str) -> dict:
    """Fetch user data from the API."""
    async with httpx.AsyncClient() as client:
        response = await client.get(f"https://api.example.com/users/{username}")
        response.raise_for_status()
        return response.json()
```

This decorator converts all httpx exceptions into user-friendly messages:

| Exception | Message |
|-----------|---------|
| `httpx.HTTPStatusError` (401) | "Authentication failed or missing credentials" |
| `httpx.HTTPStatusError` (403) | "Access denied - insufficient permissions" |
| `httpx.HTTPStatusError` (404) | "Resource not found" |
| `httpx.HTTPStatusError` (429) | "Rate limit exceeded, please retry later" |
| `httpx.HTTPStatusError` (5xx) | "Server error, please try again later" |
| `httpx.HTTPStatusError` (other) | "HTTP error {status_code}" |
| `httpx.TimeoutException` | "Request timed out, please try again" |
| `httpx.RequestError` | "Network connection error" |

### When to Use the Decorator

Use `@handle_http_errors()` when you want:
- **All HTTP errors** to have friendly messages (not just 429/timeouts)
- **404 errors** to show "Resource not found" instead of a generic error
- **Authentication errors** (401, 403) to have specific messages

If you only need rate limiting and timeout handling, the built-in behavior is sufficient.

### Decorator Options

```python
# Default: mask generic exceptions
@handle_http_errors()
async def my_tool(): ...

# Development: show exception details for non-HTTP errors
@handle_http_errors(mask_errors=False)
async def my_tool(): ...
```

<Warning>
When `mask_errors=False`, exception details are exposed to the LLM. Don't use this in production as it may leak sensitive information.
</Warning>

### Sync and Async Support

The decorator works with both sync and async functions:

```python
# Async tool
@mcp.tool
@handle_http_errors()
async def async_fetch(url: str) -> str:
    async with httpx.AsyncClient() as client:
        response = await client.get(url)
        response.raise_for_status()
        return response.text

# Sync tool - same decorator
@mcp.tool
@handle_http_errors()
def sync_fetch(url: str) -> str:
    response = httpx.get(url)
    response.raise_for_status()
    return response.text
```

### Custom Error Messages

The decorator passes through `ToolError` exceptions unchanged, so you can override the default behavior for specific cases:

```python
from fastmcp.exceptions import ToolError

@mcp.tool
@handle_http_errors()
async def fetch_user(username: str) -> dict:
    async with httpx.AsyncClient() as client:
        response = await client.get(f"https://api.example.com/users/{username}")
        
        # Custom message for 404
        if response.status_code == 404:
            raise ToolError(f"User '{username}' does not exist")
        
        response.raise_for_status()  # Other errors handled by decorator
        return response.json()
```

## Complete Example

Here's a server demonstrating both built-in error handling and the optional decorator:

```python
from fastmcp import FastMCP
from fastmcp.error_handling import handle_http_errors
from fastmcp.exceptions import ToolError
import httpx

# Production server with error masking
mcp = FastMCP("DataServer", mask_error_details=True)

# Tool using built-in error handling only
# - 429 and timeouts automatically get friendly messages
# - Other errors show "Error calling tool 'get_data'"
@mcp.tool
async def get_data(id: str) -> dict:
    """Get data by ID."""
    async with httpx.AsyncClient() as client:
        response = await client.get(f"https://api.example.com/data/{id}")
        response.raise_for_status()
        return response.json()

# Tool using decorator for granular HTTP error messages
# - All HTTP errors get specific friendly messages
@mcp.tool
@handle_http_errors()
async def get_user(username: str) -> dict:
    """Get user profile."""
    async with httpx.AsyncClient() as client:
        response = await client.get(f"https://api.example.com/users/{username}")
        response.raise_for_status()
        return response.json()

# Tool with custom error for business logic
@mcp.tool
async def transfer_funds(from_account: str, to_account: str, amount: float) -> dict:
    """Transfer funds between accounts."""
    if amount <= 0:
        raise ToolError("Amount must be positive")
    if amount > 10000:
        raise ToolError("Amount exceeds daily limit of $10,000")
    # ... implementation
```

## Troubleshooting

<Accordion title="Generic error message instead of specific HTTP error">
  **Problem:** You're seeing "Error calling tool 'my_tool'" instead of "Resource not found" for a 404.
  
  **Cause:** The built-in error handling only provides friendly messages for actionable errors (429, timeouts). Other HTTP errors are masked.
  
  **Solution:** Use the `@handle_http_errors()` decorator to get friendly messages for all HTTP status codes.
</Accordion>

<Accordion title="Sensitive information appearing in error messages">
  **Problem:** Internal error details are being sent to the LLM.
  
  **Cause:** Either `mask_error_details=False` on the server or `mask_errors=False` on the decorator.
  
  **Solution:** For production, ensure:
  ```python
  mcp = FastMCP("MyServer", mask_error_details=True)
  
  # If using decorator:
  @handle_http_errors()  # mask_errors=True by default
  ```
</Accordion>

<Accordion title="ToolError message being modified">
  **Problem:** Your custom ToolError message is being changed.
  
  **Cause:** This shouldn't happen—both the built-in handling and decorator pass ToolError through unchanged.
  
  **Solution:** Check that you're raising `ToolError` directly and not wrapping it in another exception.
</Accordion>

<Accordion title="Tool hangs on cancellation">
  **Problem:** Tool continues running after client disconnects.
  
  **Cause:** The decorator re-raises `asyncio.CancelledError` to allow proper cancellation.
  
  **Solution:** Ensure your async code uses `await` properly and doesn't suppress `CancelledError`.
</Accordion>
