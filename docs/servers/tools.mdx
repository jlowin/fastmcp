---
title: Tools
sidebarTitle: Tools
description: Expose functions as executable capabilities for your MCP client.
icon: wrench
---

import { VersionBadge } from '/snippets/version-badge.mdx'

Tools are Python functions that LLMs can invoke through the MCP protocol. When an LLM decides to use a tool, it sends a request with parameters. FastMCP validates those parameters against your function's signature, executes the function, and returns the result to the LLM for use in its response. This allows LLMs to query databases, call APIs, make calculations, or access filesâ€”extending their capabilities beyond what's in their training data.

## Overview

Decorate any Python function with `@mcp.tool` to expose it as a tool:

```python
from fastmcp import FastMCP

mcp = FastMCP(name="CalculatorServer")

@mcp.tool
def add(a: int, b: int) -> int:
    """Adds two integer numbers together."""
    return a + b
```

FastMCP extracts everything it needs from your function definition: the function name becomes the tool name, the docstring becomes the description, and type annotations generate the input schema. Validation happens automatically based on your types.

<Tip>
Functions with `*args` or `**kwargs` are not supported as tools. FastMCP needs to generate a complete parameter schema for MCP, which requires knowing all parameters at registration time.
</Tip>

### Decorator Arguments

Override inferred values or add metadata with decorator arguments:

```python
@mcp.tool(
    name="find_products",
    description="Search the product catalog with optional category filtering.",
    tags={"catalog", "search"},
)
def search_products_implementation(query: str, category: str | None = None) -> list[dict]:
    """Internal docstring (ignored when description is provided)."""
    return [{"id": 1, "name": "Widget"}]
```

<Card icon="code" title="@tool Decorator Arguments">
<ParamField body="name" type="str | None">
  Tool name exposed via MCP. Defaults to the function name.
</ParamField>

<ParamField body="description" type="str | None">
  Description exposed via MCP. Defaults to the function's docstring.
</ParamField>

<ParamField body="tags" type="set[str] | None">
  Categorization tags for filtering and organization.
</ParamField>

<ParamField body="icons" type="list[Icon] | None">
  <VersionBadge version="2.13.0" />
  Icon representations for this tool. See [Icons](/servers/icons).
</ParamField>

<ParamField body="annotations" type="ToolAnnotations | dict | None">
  MCP annotations describing tool behavior (read-only, destructive, etc.). See [Annotations](#annotations).
</ParamField>

<ParamField body="meta" type="dict[str, Any] | None">
  <VersionBadge version="2.11.0" />
  Custom metadata passed through to clients.
</ParamField>

<ParamField body="timeout" type="float | None">
  <VersionBadge version="3.0.0" />
  Execution timeout in seconds. See [Timeouts](#timeouts).
</ParamField>

<ParamField body="version" type="str | int | None">
  <VersionBadge version="3.0.0" />
  Version identifier. See [Versioning](/servers/versioning).
</ParamField>
</Card>

### Instance Methods

The `@mcp.tool` decorator registers tools immediately, which doesn't work with instance methods (you'd see `self` as a required parameter). Use the standalone `@tool` decorator to attach metadata, then register the bound method:

```python
from fastmcp import FastMCP
from fastmcp.tools import tool

class Calculator:
    def __init__(self, multiplier: int):
        self.multiplier = multiplier

    @tool()
    def multiply(self, x: int) -> int:
        """Multiply x by the instance multiplier."""
        return x * self.multiplier

calc = Calculator(multiplier=3)
mcp = FastMCP()
mcp.add_tool(calc.multiply)  # Schema shows only 'x', not 'self'
```

### Annotations

<VersionBadge version="2.2.7" />

Annotations communicate tool behavior to clients without consuming LLM context. Clients use these hints to determine when to skip confirmation prompts, how to display tools, and whether operations are safe.

```python
from fastmcp import FastMCP

mcp = FastMCP()

@mcp.tool(annotations={"readOnlyHint": True})
def get_user(user_id: str) -> dict:
    """Retrieve user information by ID."""
    return {"id": user_id, "name": "Alice"}

@mcp.tool(annotations={"destructiveHint": True})
def delete_user(user_id: str) -> dict:
    """Permanently delete a user account."""
    return {"deleted": user_id}
```

| Annotation | Type | Default | Purpose |
| :--------- | :--- | :------ | :------ |
| `title` | string | - | Display name for user interfaces |
| `readOnlyHint` | boolean | false | Tool only reads data, makes no changes |
| `destructiveHint` | boolean | true | Changes cannot be undone (for non-readonly tools) |
| `idempotentHint` | boolean | false | Repeated calls have the same effect as one call |
| `openWorldHint` | boolean | true | Tool interacts with external systems |

Mark a tool as read-only when it retrieves data, performs calculations, or checks status without modifying state. Clients like Claude and ChatGPT use `readOnlyHint` to skip confirmation prompts for safe operations.

### Removing Tools

<VersionBadge version="2.3.4" />

Remove tools dynamically with `remove_tool()`:

```python
from fastmcp import FastMCP

mcp = FastMCP()

@mcp.tool
def temporary_tool() -> str:
    return "I won't be here long"

mcp.remove_tool("temporary_tool")
```

## Inputs

FastMCP converts Python function signatures into MCP tool schemas. Type annotations determine argument types, defaults determine whether parameters are required, and Pydantic's `Field` adds validation constraints and descriptions.

### Type Annotations

MCP tools have typed arguments. FastMCP inspects your type annotations to generate the schema:

```python
from fastmcp import FastMCP

mcp = FastMCP()

@mcp.tool
def analyze_text(
    text: str,
    max_tokens: int = 100,
    language: str | None = None
) -> dict:
    """Analyze the provided text."""
    return {"length": len(text), "language": language}
```

FastMCP supports all types that Pydantic supports, including:

| Type Annotation | Example | Description |
| :-------------- | :------ | :---------- |
| Basic types | `int`, `float`, `str`, `bool` | Simple scalar values |
| Binary data | `bytes` | Raw strings (not auto-decoded base64) |
| Date and Time | `datetime`, `date`, `timedelta` | ISO format strings |
| Collection types | `list[str]`, `dict[str, int]`, `set[int]` | Collections of items |
| Optional types | `float \| None`, `Optional[float]` | Parameters that may be null |
| Union types | `str \| int`, `Union[str, int]` | Multiple accepted types |
| Constrained types | `Literal["A", "B"]`, `Enum` | Specific allowed values |
| Paths | `Path` | File system paths (auto-converted) |
| UUIDs | `UUID` | Auto-converted from strings |
| Pydantic models | `UserData` | Complex structured data |

**Binary Data**: `bytes` parameters accept raw strings. For base64-encoded data, use `str` and decode manually with `base64.b64decode()`.

**Enums**: Clients send enum values (`"red"`), not names (`"RED"`). Your function receives the Enum member (`Color.RED`).

**Paths and UUIDs**: String inputs are automatically converted to `Path` and `UUID` objects.

**Pydantic Models**: Must be provided as JSON objects (dicts), not stringified JSON. `{"user": {"name": "Alice"}}` works; `{"user": '{"name": "Alice"}'}` does not.

<Note>
FastMCP automatically dereferences `$ref` entries in tool schemas to ensure compatibility with MCP clients that don't fully support JSON Schema references. Complex Pydantic models are inlined rather than using `$defs`.
</Note>

### Required vs Optional

Parameters without default values are required. Parameters with default values are optional:

```python
@mcp.tool
def search_products(
    query: str,                   # Required
    max_results: int = 10,        # Optional
    sort_by: str = "relevance",   # Optional
    category: str | None = None   # Optional, can be None
) -> list[dict]:
    """Search the product catalog."""
    return []
```

The LLM must provide `query`. Other parameters use their defaults if omitted.

### Parameter Descriptions

<VersionBadge version="2.11.0" />

For basic descriptions, use `Annotated` with a string:

```python
from typing import Annotated
from fastmcp import FastMCP

mcp = FastMCP()

@mcp.tool
def process_image(
    image_url: Annotated[str, "URL of the image to process"],
    resize: Annotated[bool, "Whether to resize the image"] = False,
    width: Annotated[int, "Target width in pixels"] = 800,
) -> dict:
    """Process an image with optional resizing."""
    return {"url": image_url, "resized": resize}
```

This shorthand is equivalent to `Field(description=...)` but more concise.

### Validation with Field

For validation constraints and advanced metadata, use Pydantic's `Field`:

```python
from typing import Annotated, Literal
from pydantic import Field
from fastmcp import FastMCP

mcp = FastMCP()

@mcp.tool
def process_image(
    image_url: Annotated[str, Field(description="URL of the image to process")],
    width: Annotated[int, Field(description="Target width in pixels", ge=1, le=2000)] = 800,
    format: Annotated[
        Literal["jpeg", "png", "webp"],
        Field(description="Output image format")
    ] = "jpeg"
) -> dict:
    """Process an image with optional resizing."""
    return {"url": image_url, "width": width, "format": format}
```

Field supports these validation options:

| Option | Purpose |
| :----- | :------ |
| `description` | Human-readable explanation shown to LLMs |
| `ge` / `gt` / `le` / `lt` | Numeric constraints (greater/less than) |
| `min_length` / `max_length` | String or collection length constraints |
| `pattern` | Regex pattern for string validation |
| `default` | Default value if parameter is omitted |

You can also use Field as a default value, though `Annotated` is preferred:

```python
@mcp.tool
def search_database(
    query: str = Field(description="Search query string"),
    limit: int = Field(10, description="Maximum results", ge=1, le=100)
) -> list:
    """Search the database."""
    return []
```

### Hidden Parameters

<VersionBadge version="2.14.0" />

To inject values at runtime without exposing them to the LLM, use dependency injection with `Depends()`. Parameters using `Depends()` are automatically excluded from the tool schema:

```python
from fastmcp import FastMCP
from fastmcp.dependencies import Depends

mcp = FastMCP()

def get_user_id() -> str:
    return "user_123"

@mcp.tool
def get_user_details(user_id: str = Depends(get_user_id)) -> str:
    # user_id is injected by the server, not provided by the LLM
    return f"Details for {user_id}"
```

See [Custom Dependencies](/servers/context#custom-dependencies) for more dependency injection patterns.

### Validation Modes

<VersionBadge version="2.13.0" />

By default, FastMCP uses Pydantic's flexible validation that coerces compatible inputs. This handles LLM clients that send string representations of values (like `"10"` for an integer).

For stricter validation that rejects type mismatches, enable strict mode:

```python
from fastmcp import FastMCP

mcp = FastMCP("StrictServer", strict_input_validation=True)

@mcp.tool
def add_numbers(a: int, b: int) -> int:
    """Add two numbers."""
    return a + b

# With strict_input_validation=True:
#   {"a": "10", "b": "20"} fails validation
# With strict_input_validation=False (default):
#   {"a": "10", "b": "20"} coerces to integers
```

| Input | Default (flexible) | Strict |
| :---- | :----------------- | :----- |
| `"10"` for `int` | Coerced to 10 | Validation error |
| `"3.14"` for `float` | Coerced to 3.14 | Validation error |
| `"true"` for `bool` | Coerced to True | Validation error |
| `["1", "2"]` for `list[int]` | Elements coerced | Validation error |
| `"abc"` for `int` | Validation error | Validation error |

Flexible validation is recommended for most use cases. It handles common LLM client behaviors while maintaining type safety through Pydantic.

## Outputs

FastMCP tools produce two complementary output formats: traditional content blocks (text, images) for human consumption and structured outputs (JSON) for machine processing. Return type annotations generate output schemas that validate and describe the structured data.

### Content Blocks

FastMCP converts return values into MCP content blocks automatically:

| Return Type | MCP Content |
| :---------- | :---------- |
| `str` | `TextContent` |
| `bytes` | Base64-encoded `EmbeddedResource` |
| `Image` | `ImageContent` |
| `Audio` | `AudioContent` |
| `File` | Base64-encoded `EmbeddedResource` |
| MCP SDK content blocks | Passed through as-is |
| `list` of the above | Each item converted individually |
| `None` | Empty response |

### Media Helpers

FastMCP provides helper classes for returning rich media:

```python
from fastmcp import FastMCP
from fastmcp.utilities.types import Image, Audio, File

mcp = FastMCP()

@mcp.tool
def get_chart() -> Image:
    """Generate a chart image."""
    return Image(path="chart.png")

@mcp.tool
def get_multiple_charts() -> list[Image]:
    """Return multiple charts."""
    return [Image(path="chart1.png"), Image(path="chart2.png")]
```

Each helper accepts either `path=` or `data=` (mutually exclusive):

| Parameter | Purpose |
| :-------- | :------ |
| `path` | File path (string or Path). MIME type detected from extension. |
| `data` | Raw bytes. Requires `format=` parameter. |
| `format` | Optional format override ("png", "wav", "pdf") |
| `name` | Optional name for `File` when using `data=` |
| `annotations` | Optional MCP annotations |

<Tip>
Helpers are only auto-converted when returned directly or in a list. For nested structures like dicts, convert manually:

```python
# Direct return - auto-converted
return Image(path="chart.png")

# Nested - manual conversion needed
return {"image": Image(path="chart.png").to_image_content()}
```
</Tip>

### Structured Output

<VersionBadge version="2.10.0" />

The MCP spec supports structured content: JSON data sent alongside traditional content for machine processing. FastMCP generates structured output automatically based on what your tool returns.

**Dictionaries, dataclasses, and Pydantic models** automatically become structured content:

<CodeGroup>
```python Tool Definition
from fastmcp import FastMCP

mcp = FastMCP()

@mcp.tool
def get_user_data(user_id: str) -> dict:
    """Get user data."""
    return {"name": "Alice", "age": 30, "active": True}
```

```json MCP Result
{
  "content": [
    {
      "type": "text",
      "text": "{\n  \"name\": \"Alice\",\n  \"age\": 30,\n  \"active\": true\n}"
    }
  ],
  "structuredContent": {
    "name": "Alice",
    "age": 30,
    "active": true
  }
}
```
</CodeGroup>

The same data appears in both `content` (for display) and `structuredContent` (for programmatic access).

**Primitives and collections** only become structured content when you add a return type annotation. The annotation tells FastMCP how to validate and serialize the result.

Without an annotation, only `content` is returned:

<CodeGroup>
```python No Annotation
@mcp.tool
def calculate_sum(a: int, b: int):
    """Calculate sum."""
    return a + b  # Returns 8
```

```json MCP Result
{
  "content": [{"type": "text", "text": "8"}]
}
```
</CodeGroup>

With an annotation, FastMCP wraps the primitive in `{"result": ...}` for structured output:

<CodeGroup>
```python With Annotation
@mcp.tool
def calculate_sum(a: int, b: int) -> int:
    """Calculate sum."""
    return a + b  # Returns 8
```

```json MCP Result
{
  "content": [{"type": "text", "text": "8"}],
  "structuredContent": {"result": 8}
}
```
</CodeGroup>

### Typed Models

Dataclasses and Pydantic models produce detailed output schemas with field definitions:

<CodeGroup>
```python Tool Definition
from dataclasses import dataclass
from fastmcp import FastMCP

mcp = FastMCP()

@dataclass
class Person:
    name: str
    age: int
    email: str

@mcp.tool
def get_user_profile(user_id: str) -> Person:
    """Get a user's profile information."""
    return Person(name="Alice", age=30, email="alice@example.com")
```

```json Output Schema
{
  "properties": {
    "name": {"title": "Name", "type": "string"},
    "age": {"title": "Age", "type": "integer"},
    "email": {"title": "Email", "type": "string"}
  },
  "required": ["name", "age", "email"],
  "title": "Person",
  "type": "object"
}
```

```json MCP Result
{
  "content": [
    {"type": "text", "text": "{\"name\": \"Alice\", \"age\": 30, \"email\": \"alice@example.com\"}"}
  ],
  "structuredContent": {
    "name": "Alice",
    "age": 30,
    "email": "alice@example.com"
  }
}
```
</CodeGroup>

### Output Schemas

<VersionBadge version="2.10.0" />

Output schemas describe the expected format of structured output. FastMCP generates them from return type annotations. When a schema is provided, the tool must return structured output that matches it.

Override the auto-generated schema with a custom one:

```python
from fastmcp import FastMCP

mcp = FastMCP()

@mcp.tool(output_schema={
    "type": "object",
    "properties": {
        "data": {"type": "string"},
        "metadata": {"type": "object"}
    }
})
def custom_schema_tool() -> dict:
    """Tool with custom output schema."""
    return {"data": "Hello", "metadata": {"version": "1.0"}}
```

<Warning>
Output schemas must be object types (`"type": "object"`). If you provide an output schema, your tool must return structured output that matches it.
</Warning>

### ToolResult

For complete control over tool responses, return a `ToolResult`. This gives you explicit control over content, structured data, and metadata independently.

```python
from fastmcp import FastMCP
from fastmcp.tools.tool import ToolResult
from mcp.types import TextContent

mcp = FastMCP()

@mcp.tool
def advanced_tool() -> ToolResult:
    """Tool with full control over output."""
    return ToolResult(
        content=[TextContent(type="text", text="Human-readable summary")],
        structured_content={"data": "value", "count": 42},
        meta={"execution_time_ms": 145}
    )
```

**Content Field**: The traditional MCP content blocks for display. Accepts a string (auto-converted to `TextContent`), a list of MCP content blocks, or any serializable value (converted to JSON string).

```python
# String
ToolResult(content="Hello, world!")

# Content blocks
ToolResult(content=[
    TextContent(type="text", text="Result: 42"),
    ImageContent(type="image", data="base64...", mimeType="image/png")
])
```

**Structured Content Field**: A dictionary containing structured data for programmatic access. If only `structured_content` is provided, it's also used as `content` (converted to JSON string).

```python
ToolResult(
    content="Found 3 users",
    structured_content={"users": [{"name": "Alice"}, {"name": "Bob"}]}
)
```

**Meta Field** <VersionBadge version="2.13.1" />: Runtime metadata about tool execution. Use for performance metrics, debugging information, or client-specific data.

```python
ToolResult(
    content="Analysis complete",
    structured_content={"result": "positive"},
    meta={
        "execution_time_ms": 145,
        "model_version": "2.1",
        "confidence": 0.95
    }
)
```

<Note>
The `meta` field in `ToolResult` is runtime metadata about execution. The `meta` parameter in `@mcp.tool(meta={...})` is static metadata about the tool definition itself.
</Note>

### Custom Serialization

When you need custom serialization (YAML, Markdown tables, specialized formats), return `ToolResult` with your serialized content:

```python
import yaml
from fastmcp import FastMCP
from fastmcp.tools.tool import ToolResult

mcp = FastMCP()

@mcp.tool
def get_config() -> ToolResult:
    """Returns configuration as YAML."""
    data = {"api_key": "abc123", "debug": True, "rate_limit": 100}
    return ToolResult(
        content=yaml.dump(data, sort_keys=False),
        structured_content=data
    )
```

<Tip>
For reusable serialization across multiple tools, create a wrapper decorator that returns `ToolResult`. See [examples/custom_tool_serializer_decorator.py](https://github.com/jlowin/fastmcp/blob/main/examples/custom_tool_serializer_decorator.py) for a complete implementation.
</Tip>

## Runtime

Runtime behavior covers how tools execute: async vs sync, timeouts, error handling, and accessing MCP context for logging and progress reporting.

### Async Support

FastMCP supports both `async def` and regular `def` functions as tools. Synchronous tools run in a threadpool automatically, so they don't block the event loop and can execute concurrently with other operations.

```python
from fastmcp import FastMCP
import time

mcp = FastMCP()

@mcp.tool
def slow_tool(x: int) -> int:
    """This sync function won't block other concurrent requests."""
    time.sleep(2)  # Runs in threadpool
    return x * 2
```

For I/O-bound operations like network requests or database queries, async tools are more efficient than threadpool dispatch. Use sync tools when working with synchronous libraries or for simple operations where the threading overhead doesn't matter.

### Timeouts

<VersionBadge version="3.0.0" />

Tools can specify a `timeout` parameter to limit execution time. When the timeout is exceeded, the client receives an MCP error and the tool stops processing.

```python
from fastmcp import FastMCP

mcp = FastMCP()

@mcp.tool(timeout=30.0)
async def fetch_data(url: str) -> dict:
    """Fetch data with a 30-second timeout."""
    # If this takes longer than 30 seconds,
    # the client receives an MCP error
    ...
```

Timeouts are specified in seconds as a float. When exceeded, FastMCP returns an MCP error with code `-32000` and a message indicating which tool timed out. Both sync and async tools support timeouts.

<Note>
Tools must explicitly opt-in to timeouts. There is no server-level default timeout setting.
</Note>

### Background Tasks

Timeouts apply to foreground execution only. When a tool runs as a background task (`task=True`), the FastMCP timeout is not enforced.

For task timeouts, use Docket's `Timeout` dependency:

```python
from datetime import timedelta
from docket import Timeout
from fastmcp import FastMCP

mcp = FastMCP()

@mcp.tool(task=True)
async def long_running_task(
    data: str,
    timeout: Timeout = Timeout(timedelta(minutes=10))
) -> str:
    """Task with a 10-minute timeout enforced by Docket."""
    ...
```

See the [Docket documentation](https://chrisguidry.github.io/docket/dependencies/#task-timeouts) for more on task timeouts and retries.

### Error Handling

<VersionBadge version="2.4.1" />

When tools encounter errors, raise a standard Python exception (`ValueError`, `TypeError`, `FileNotFoundError`, etc.) or FastMCP's `ToolError`. By default, all exceptions are logged and converted into MCP error responses.

For security, mask internal error details from clients:

```python
from fastmcp import FastMCP

mcp = FastMCP(name="SecureServer", mask_error_details=True)
```

With `mask_error_details=True`, generic exception messages are hidden. To expose specific errors intentionally, use `ToolError`:

```python
from fastmcp import FastMCP
from fastmcp.exceptions import ToolError

mcp = FastMCP(mask_error_details=True)

@mcp.tool
def divide(a: float, b: float) -> float:
    """Divide a by b."""
    if b == 0:
        # This message is always sent to clients
        raise ToolError("Division by zero is not allowed.")

    # This message would be masked
    if not isinstance(a, (int, float)):
        raise TypeError("Both arguments must be numbers.")

    return a / b
```

`ToolError` messages are always sent to clients regardless of the `mask_error_details` setting. Use it when you want to communicate specific, safe error information.

### Context Access

Tools can access MCP features through the `Context` object: logging, progress reporting, resource reading, and LLM sampling. Add a parameter with the `Context` type hint:

```python
from fastmcp import FastMCP, Context

mcp = FastMCP()

@mcp.tool
async def process_data(data_uri: str, ctx: Context) -> dict:
    """Process data from a resource with progress reporting."""
    await ctx.info(f"Processing data from {data_uri}")

    # Read a resource
    resource = await ctx.read_resource(data_uri)
    data = resource[0].content if resource else ""

    # Report progress
    await ctx.report_progress(progress=50, total=100)

    # Request LLM help
    summary = await ctx.sample(f"Summarize this in 10 words: {data[:200]}")

    await ctx.report_progress(progress=100, total=100)
    return {
        "length": len(data),
        "summary": summary.text
    }
```

| Method | Purpose |
| :----- | :------ |
| `ctx.debug()`, `ctx.info()`, `ctx.warning()`, `ctx.error()` | Logging |
| `ctx.report_progress(progress, total)` | Progress reporting |
| `ctx.read_resource(uri)` | Read a resource |
| `ctx.sample(...)` | Request LLM completion |
| `ctx.request_id` | Current request identifier |
| `ctx.client_id` | Connected client identifier |

See [Context](/servers/context) for complete documentation on context capabilities and custom dependencies.

## Server Configuration

### Duplicate Tools

<VersionBadge version="2.1.0" />

Control how the server behaves when registering multiple tools with the same name:

```python
from fastmcp import FastMCP

mcp = FastMCP(
    name="StrictServer",
    on_duplicate_tools="error"
)
```

| Option | Behavior |
| :----- | :------- |
| `"warn"` (default) | Logs a warning, new tool replaces old |
| `"error"` | Raises `ValueError`, prevents duplicate |
| `"replace"` | Silently replaces existing tool |
| `"ignore"` | Keeps original, ignores new registration |

### Visibility Control

<VersionBadge version="3.0.0" />

Control which tools are visible to clients. Disabled tools don't appear in `list_tools` and can't be called:

```python
from fastmcp import FastMCP

mcp = FastMCP()

@mcp.tool(tags={"admin"})
def admin_action() -> str:
    return "Done"

@mcp.tool(tags={"public"})
def public_action() -> str:
    return "Done"

# Disable by key
mcp.disable(keys=["tool:admin_action"])

# Disable by tag
mcp.disable(tags={"admin"})

# Allowlist mode - only show tools with specific tags
mcp.enable(tags={"public"}, only=True)
```

See [Local Provider](/servers/providers/local#visibility-control) for the complete visibility control API.

### Notifications

<VersionBadge version="2.9.1" />

FastMCP automatically sends `notifications/tools/list_changed` notifications to connected clients when tools are added, removed, enabled, or disabled. Clients can handle these notifications using a [message handler](/clients/messages) to automatically refresh their tool lists.

### Versioning

<VersionBadge version="3.0.0" />

Tools support versioning, allowing you to maintain multiple implementations under the same name while clients automatically receive the highest version. See [Versioning](/servers/versioning) for complete documentation.
