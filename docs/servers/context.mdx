---
title: Context
sidebarTitle: Context
description: Access MCP capabilities like logging, progress, sampling, session state, and dependencies within your tools, resources, and prompts.
icon: rectangle-code
tag: NEW
---

import { VersionBadge } from '/snippets/version-badge.mdx'

Context is the gateway to MCP capabilities beyond simple request/response. When your functions need to log messages, report progress, read resources, store session data, or access HTTP request details, context provides that access.

## Overview

The `Context` object gives your functions access to MCP features that require session awareness:

- **Logging**: Send debug, info, warning, and error messages to the client
- **Progress Reporting**: Update clients on long-running operations
- **Resource Access**: List and read resources registered with the server
- **Prompt Access**: List and retrieve prompts programmatically
- **LLM Sampling**: Request the client's LLM to generate text
- **User Elicitation**: Request structured input from users during execution
- **Session State**: Store data that persists across requests within a session
- **Request Metadata**: Access request IDs, client IDs, and transport information

### Getting Context

<VersionBadge version="2.14" />

Inject context into any tool, resource, or prompt function using the `CurrentContext()` dependency:

```python
from fastmcp import FastMCP
from fastmcp.dependencies import CurrentContext
from fastmcp.server.context import Context

mcp = FastMCP(name="Context Demo")

@mcp.tool
async def process_file(file_uri: str, ctx: Context = CurrentContext()) -> str:
    """Process a file with logging and progress."""
    await ctx.info(f"Processing {file_uri}")
    await ctx.report_progress(progress=50, total=100)
    return "Processed file"
```

The same pattern works for resources and prompts:

```python
from fastmcp import FastMCP
from fastmcp.dependencies import CurrentContext
from fastmcp.server.context import Context

mcp = FastMCP(name="Context Demo")

@mcp.resource("resource://user-data")
async def get_user_data(ctx: Context = CurrentContext()) -> dict:
    await ctx.debug("Fetching user data")
    return {"user_id": "example"}

@mcp.prompt
async def data_analysis_request(dataset: str, ctx: Context = CurrentContext()) -> str:
    return f"Please analyze the following dataset: {dataset}"
```

Dependency parameters like `CurrentContext()` are automatically excluded from the MCP schema—clients never see them as parameters they need to provide.

### Type-Hint Injection

For backwards compatibility, adding a parameter with the `Context` type hint also works. FastMCP injects the context instance automatically:

```python
from fastmcp import FastMCP, Context

mcp = FastMCP(name="Context Demo")

@mcp.tool
async def process_file(file_uri: str, ctx: Context) -> str:
    """Context is injected based on the type hint."""
    return "Processed file"
```

The parameter name is irrelevant—only the `Context` type hint matters. This also works with `Context | None` and `Annotated[]`.

### Getting Context Anywhere

<VersionBadge version="2.2.11" />

For code nested deeper in your call stack where passing context through parameters is impractical, use `get_context()` to retrieve the active context from anywhere within a request's execution flow:

```python
from fastmcp import FastMCP
from fastmcp.server.dependencies import get_context

mcp = FastMCP(name="Dependency Demo")

async def process_data(data: list[float]) -> dict:
    """Utility function that needs context but doesn't receive it as a parameter."""
    ctx = get_context()
    await ctx.info(f"Processing {len(data)} data points")
    return {"processed": len(data)}

@mcp.tool
async def analyze_dataset(dataset_name: str) -> dict:
    data = load_data(dataset_name)
    return await process_data(data)
```

The `get_context()` function only works within a server request. Calling it outside a request raises `RuntimeError`.

### Request Scope

Each MCP request receives a fresh context object. State or data set on context during one request is not automatically available in subsequent requests—that's what session state is for (see below).

Context methods are async, so your function usually needs to be `async` as well. Context is only valid during a request; calling context methods outside a request flow raises errors.

### Request Information

Access metadata about the current request and client:

```python
from fastmcp import FastMCP, Context

mcp = FastMCP(name="Request Info Demo")

@mcp.tool
async def request_info(ctx: Context) -> dict:
    """Return information about the current request."""
    return {
        "request_id": ctx.request_id,
        "client_id": ctx.client_id or "Unknown client",
        "session_id": ctx.session_id
    }
```

| Property | Type | Description |
|----------|------|-------------|
| `ctx.request_id` | `str` | Unique ID for the current MCP request |
| `ctx.client_id` | `str \| None` | Client ID if provided during initialization |
| `ctx.session_id` | `str` | MCP session ID (raises `RuntimeError` if session not established) |

### Server and Transport

Access the underlying server instance or check which transport is being used:

```python
from fastmcp import FastMCP, Context

mcp = FastMCP("example")

@mcp.tool
def connection_info(ctx: Context) -> str:
    server_name = ctx.fastmcp.name

    if ctx.transport == "stdio":
        return f"{server_name} connected via STDIO"
    elif ctx.transport == "sse":
        return f"{server_name} connected via SSE"
    elif ctx.transport == "streamable-http":
        return f"{server_name} connected via Streamable HTTP"
    else:
        return f"{server_name} transport unknown"
```

The transport type is set when the server starts and remains constant. It returns `None` outside a server context (in unit tests, for example).

## Session State

<VersionBadge version="3.0.0" />

Session state persists data across multiple tool calls or requests within the same client session—counters, user preferences, conversation history, or cached computations.

State is automatically keyed by the client's MCP session ID. Each client gets isolated storage—two clients calling the same tool maintain independent state.

```python
from fastmcp import FastMCP, Context

mcp = FastMCP("stateful-app")

@mcp.tool
async def increment_counter(ctx: Context) -> int:
    """Increment a counter that persists across tool calls."""
    count = await ctx.get_state("counter") or 0
    await ctx.set_state("counter", count + 1)
    return count + 1

@mcp.tool
async def get_counter(ctx: Context) -> int:
    """Get the current counter value."""
    return await ctx.get_state("counter") or 0
```

### State Methods

| Method | Description |
|--------|-------------|
| `await ctx.set_state(key, value)` | Store a value in session state |
| `await ctx.get_state(key)` | Retrieve a value (returns `None` if not found) |
| `await ctx.delete_state(key)` | Remove a value from session state |

All state methods are async and require `await`. State expires after 1 day by default to prevent unbounded memory growth.

### Storage Backends

By default, session state uses an in-memory store suitable for single-server deployments. For distributed or serverless deployments where different server instances may handle requests from the same session, provide a custom storage backend:

```python
from key_value.aio.stores.redis import RedisStore

mcp = FastMCP("distributed-app", session_state_store=RedisStore(...))
```

Any backend compatible with the [py-key-value-aio](https://github.com/strawgate/py-key-value) `AsyncKeyValue` protocol works. See [Storage Backends](/servers/storage-backends) for configuration options including Redis, DynamoDB, and MongoDB.

### State During Initialization

State set during `on_initialize` middleware persists to subsequent tool calls when using the same session object (STDIO, SSE, single-server HTTP). For distributed or serverless HTTP deployments where different machines handle initialization and tool calls, state is isolated by the `mcp-session-id` header.

### State Pitfalls

**State is session-scoped, not request-scoped.** If you need data only for the current request, use regular variables. Session state is for data that must survive across separate tool invocations.

**Memory growth in single-server mode.** Without a TTL or external storage, long-running servers accumulate state. The default 1-day expiration helps, but monitor memory for high-volume servers.

**Serialization constraints.** Values must be serializable by the storage backend. In-memory stores accept any Python object; Redis and other backends require JSON-serializable data.

## Capabilities

Context provides access to MCP capabilities that require session awareness. Each capability has dedicated documentation with comprehensive examples; this section serves as a quick reference.

### Logging

Send messages back to the MCP client for visibility into function execution.

```python
await ctx.debug("Starting analysis")
await ctx.info(f"Processing {len(data)} items")
await ctx.warning("Deprecated parameter used")
await ctx.error("Processing failed")
```

| Method | Purpose |
|--------|---------|
| `ctx.debug(message, extra=None)` | Detailed diagnostic information |
| `ctx.info(message, extra=None)` | General execution information |
| `ctx.warning(message, extra=None)` | Potential issues that didn't prevent execution |
| `ctx.error(message, extra=None)` | Errors that occurred during execution |
| `ctx.log(level, message, logger_name=None, extra=None)` | Generic logging with custom level |

See [Server Logging](/servers/logging) for complete documentation.

### Progress Reporting

Update clients on long-running operations for progress indicators and better UX.

```python
await ctx.report_progress(progress=50, total=100)  # 50% complete
```

See [Progress Reporting](/servers/progress) for patterns and examples.

### LLM Sampling

<VersionBadge version="2.0.0" />

Request the client's LLM to generate text based on provided messages.

```python
response = await ctx.sample("Analyze this data", temperature=0.7)
```

See [LLM Sampling](/servers/sampling) for advanced techniques.

### User Elicitation

<VersionBadge version="2.10.0" />

Request structured input from clients during tool execution for interactive workflows.

```python
result = await ctx.elicit("Enter your name:", response_type=str)
if result.action == "accept":
    name = result.data
```

See [User Elicitation](/servers/elicitation) for supported response types.

### Resource Access

List and read resources registered with your server.

```python
# List available resources
resources = await ctx.list_resources()

# Read a specific resource
content_list = await ctx.read_resource("resource://config")
content = content_list[0].content
```

| Method | Return Type | Description |
|--------|-------------|-------------|
| `ctx.list_resources()` | `list[MCPResource]` | <VersionBadge version="2.13.0" /> All available resources |
| `ctx.read_resource(uri)` | `list[ReadResourceContents]` | Content parts for a resource |

### Prompt Access

<VersionBadge version="2.13.0" />

List and retrieve prompts registered with your server.

```python
# List available prompts
prompts = await ctx.list_prompts()

# Get a specific prompt with arguments
result = await ctx.get_prompt("analyze_data", {"dataset": "users"})
messages = result.messages
```

| Method | Return Type | Description |
|--------|-------------|-------------|
| `ctx.list_prompts()` | `list[MCPPrompt]` | All available prompts |
| `ctx.get_prompt(name, arguments=None)` | `GetPromptResult` | Prompt with optional arguments applied |

### Change Notifications

<VersionBadge version="3.0.0" />

FastMCP automatically sends list change notifications when components are added, removed, enabled, or disabled. For manual control in rare cases:

```python
import mcp.types

# Send immediately in async code
await ctx.send_notification(mcp.types.ToolListChangedNotification())
await ctx.send_notification(mcp.types.ResourceListChangedNotification())
await ctx.send_notification(mcp.types.PromptListChangedNotification())

# Queue for background sending in sync code (~1 second delay)
ctx.send_notification_sync(mcp.types.ToolListChangedNotification())
```

### Request Context

<VersionBadge version="2.13.1" />

Access the underlying MCP request context for advanced use cases. The `ctx.request_context` property returns `None` when the MCP session has not been established yet (during early middleware execution or initialization).

```python
from fastmcp import FastMCP, Context

mcp = FastMCP(name="Session Info Demo")

@mcp.tool
async def session_info(ctx: Context) -> dict:
    if ctx.request_context:
        return {
            "session_id": ctx.session_id,
            "request_id": ctx.request_id,
            "has_meta": ctx.request_context.meta is not None
        }
    else:
        return {"message": "MCP session not available"}
```

Clients can send contextual information with requests via the `meta` parameter. Metadata is accessed as an object with attribute access:

```python
from fastmcp import FastMCP, Context

mcp = FastMCP(name="Metadata Demo")

@mcp.tool
def send_email(to: str, subject: str, body: str, ctx: Context) -> str:
    meta = ctx.request_context.meta
    if meta:
        user_id = meta.user_id if hasattr(meta, 'user_id') else None
        trace_id = meta.trace_id if hasattr(meta, 'trace_id') else None
    return f"Email sent to {to}"
```

<Warning>
The MCP request context is part of the low-level MCP SDK and intended for advanced use cases. Most users will not need to access it directly.
</Warning>

## HTTP Request Data

<VersionBadge version="2.2.11" />

HTTP request helpers provide access to transport-level details—client IP addresses, custom headers, or authentication tokens. These helpers work anywhere within a request's execution flow, not just in your MCP function.

### Getting the Request

The `get_http_request()` function returns the Starlette `Request` object:

```python
from fastmcp import FastMCP
from fastmcp.server.dependencies import get_http_request
from starlette.requests import Request

mcp = FastMCP(name="HTTP Request Demo")

@mcp.tool
async def user_agent_info() -> dict:
    """Return information about the user agent."""
    request: Request = get_http_request()

    return {
        "user_agent": request.headers.get("user-agent", "Unknown"),
        "client_ip": request.client.host if request.client else "Unknown",
        "path": request.url.path,
    }
```

This works in helper functions too, not just in your MCP tool:

```python
from fastmcp.server.dependencies import get_http_request

async def get_client_ip() -> str:
    """Helper function that accesses HTTP request data."""
    request = get_http_request()
    return request.client.host if request.client else "Unknown"
```

### Getting Headers

<VersionBadge version="2.2.11" />

For header access without the full request object, `get_http_headers()` returns a dictionary. It silently returns an empty dict if no HTTP context exists, making it safe for code that might run in non-HTTP contexts:

```python
from fastmcp import FastMCP
from fastmcp.server.dependencies import get_http_headers

mcp = FastMCP(name="Headers Demo")

@mcp.tool
async def safe_header_info() -> dict:
    """Safely get header information without raising errors."""
    headers = get_http_headers()

    auth_header = headers.get("authorization", "")
    is_bearer = auth_header.startswith("Bearer ")

    return {
        "user_agent": headers.get("user-agent", "Unknown"),
        "content_type": headers.get("content-type", "Unknown"),
        "has_auth": bool(auth_header),
        "auth_type": "Bearer" if is_bearer else "Other" if auth_header else "None",
    }
```

By default, `get_http_headers()` excludes problematic headers like `host` and `content-length`. To include all headers, use `get_http_headers(include_all=True)`.

### Access Tokens

<VersionBadge version="2.11.0" />

When using authentication, access the authenticated user's token information with `get_access_token()`:

```python
from fastmcp import FastMCP
from fastmcp.server.dependencies import get_access_token, AccessToken

mcp = FastMCP(name="Auth Token Demo")

@mcp.tool
async def get_user_info() -> dict:
    """Get information about the authenticated user."""
    token: AccessToken | None = get_access_token()

    if token is None:
        return {"authenticated": False}

    return {
        "authenticated": True,
        "client_id": token.client_id,
        "scopes": token.scopes,
        "expires_at": token.expires_at,
        "token_claims": token.claims,
    }
```

The `claims` field contains all data from the original token—JWT claims for JWT tokens, or custom data for other token types:

```python
from fastmcp import FastMCP
from fastmcp.server.dependencies import get_access_token

mcp = FastMCP(name="Multi-tenant Demo")

@mcp.tool
async def get_tenant_data(resource_id: str) -> dict:
    """Get tenant-specific data using token claims."""
    token = get_access_token()

    tenant_id = token.claims.get("tenant_id") if token else None
    user_id = token.claims.get("sub") if token else None

    if not tenant_id:
        raise ValueError("No tenant information in token")

    return {
        "resource_id": resource_id,
        "tenant_id": tenant_id,
        "user_id": user_id,
    }
```

Common use cases for token claims:

- **User identification** — Get `client_id` or subject from claims
- **Permission checks** — Verify scopes or custom claims before operations
- **Multi-tenancy** — Extract tenant information for data isolation
- **Audit logging** — Track which user performed which actions

### HTTP vs MCP Context

HTTP request data may be available even when the MCP session is not yet established. This happens during early middleware execution before the MCP handshake completes. For HTTP transports, use these helpers for request data; for MCP-specific attributes, check that `ctx.request_context` is not `None` first.

```python
from fastmcp import FastMCP, Context
from fastmcp.server.dependencies import get_http_request

mcp = FastMCP(name="Session Aware Demo")

@mcp.tool
async def session_info(ctx: Context) -> dict:
    if ctx.request_context:
        # MCP session available
        return {"session_id": ctx.session_id, "request_id": ctx.request_id}
    else:
        # MCP session not available, fall back to HTTP data
        request = get_http_request()
        return {"user_agent": request.headers.get("user-agent", "Unknown")}
```

### HTTP Pitfalls

**STDIO transport has no HTTP request.** These helpers only work with HTTP-based transports (SSE, Streamable HTTP). Calling `get_http_request()` in a STDIO server raises an error; `get_http_headers()` returns an empty dict.

**Headers are case-insensitive.** HTTP headers are case-insensitive by spec. Both `headers.get("User-Agent")` and `headers.get("user-agent")` work.

## Dependencies

<VersionBadge version="2.14" />

Custom dependencies inject configuration, database connections, API clients, or other values into your MCP functions. Dependencies are powered by [Docket](https://github.com/chrisguidry/docket) and provide automatic cleanup for resources that need it.

### Basic Dependencies

Pass any callable to `Depends()` and its return value is injected:

```python
from fastmcp import FastMCP
from fastmcp.dependencies import Depends

mcp = FastMCP(name="Custom Deps Demo")

def get_config() -> dict:
    return {"api_url": "https://api.example.com", "timeout": 30}

async def get_user_id() -> int:
    return 42

@mcp.tool
async def fetch_data(
    query: str,
    config: dict = Depends(get_config),
    user_id: int = Depends(get_user_id),
) -> str:
    return f"User {user_id} fetching '{query}' from {config['api_url']}"
```

Dependencies work with sync or async functions. Parameters using `Depends()` are automatically excluded from the MCP schema—clients never see them.

### Resource Cleanup

For dependencies that need cleanup—database connections, file handles, HTTP clients—use an async context manager:

```python
from contextlib import asynccontextmanager
from fastmcp import FastMCP
from fastmcp.dependencies import Depends

mcp = FastMCP(name="Resource Demo")

@asynccontextmanager
async def get_database():
    db = await connect_to_database()
    try:
        yield db
    finally:
        await db.close()

@mcp.tool
async def query_users(sql: str, db = Depends(get_database)) -> list:
    return await db.execute(sql)
```

The context manager's cleanup code runs after your function completes, even if an error occurs. This pattern ensures connections are properly closed and resources released.

### Nested Dependencies

Dependencies can depend on other dependencies. Docket resolves the dependency graph automatically:

```python
from fastmcp import FastMCP
from fastmcp.dependencies import Depends

mcp = FastMCP(name="Nested Demo")

def get_base_url() -> str:
    return "https://api.example.com"

def get_api_client(base_url: str = Depends(get_base_url)) -> dict:
    return {"base_url": base_url, "version": "v1"}

@mcp.tool
async def call_api(endpoint: str, client: dict = Depends(get_api_client)) -> str:
    return f"Calling {client['base_url']}/{client['version']}/{endpoint}"
```

### Built-in Dependencies

FastMCP provides several built-in dependencies:

| Dependency | Description |
|------------|-------------|
| `CurrentContext()` | The MCP context for the current request |
| `get_context()` | Function to get context from anywhere in the call stack |
| `get_http_request()` | The Starlette Request object (HTTP transports only) |
| `get_http_headers()` | Request headers as a dict (safe for non-HTTP) |
| `get_access_token()` | The authenticated user's access token |

### Advanced Patterns

For more complex dependency patterns—dependencies that need access to Docket's execution context or require custom lifecycle management—subclass Docket's `Dependency` class directly. See the [Docket documentation on dependencies](https://chrisguidry.github.io/docket/dependencies/) for details.

### Dependency Pitfalls

**Dependencies are resolved per-request.** Each request gets fresh dependency values. If you need shared state across requests, use session state or manage singletons in your dependency functions.

**Cleanup happens after the response.** Context manager cleanup runs after your function returns. If cleanup is slow, it may delay the response to the client.

**Type hints matter.** The injected value should match the type hint on your parameter. Docket doesn't enforce this at runtime, but your IDE and type checker will catch mismatches.

## Related Pages

- [Server Logging](/servers/logging) — Complete logging documentation
- [Progress Reporting](/servers/progress) — Progress patterns and examples
- [LLM Sampling](/servers/sampling) — Advanced sampling techniques
- [User Elicitation](/servers/elicitation) — Supported response types
- [Storage Backends](/servers/storage-backends) — Redis, DynamoDB, MongoDB configuration
- [Authentication](/servers/auth/authentication) — Setting up server authentication
- [HTTP Deployment](/deployment/http) — Running servers over HTTP
