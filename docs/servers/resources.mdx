---
title: Resources
description: Expose data sources and content generators to MCP clients.
---

import { VersionBadge } from "/snippets/version-badge.mdx"

Resources are read-only data sources that MCP clients can access. When a client requests a resource URI, FastMCP finds the matching definition, executes any associated function, and returns the content. This gives LLMs access to files, API responses, computed data, or anything else relevant to the conversation.

Use resources when you want LLMs to read data: configuration files, database records, generated reports, or any content the model needs for context.

## Overview

Resources come in two forms. Static resources have fixed content defined at registration time. Dynamic resources execute a function each time they're read, generating fresh content on demand.

Static resources work well for configuration files, documentation, or data that rarely changes. Dynamic resources suit situations where content depends on current state: live metrics, user-specific data, or computed values.

```python
from fastmcp import FastMCP
from fastmcp.resources import TextResource

mcp = FastMCP()

# Static: content fixed at registration
mcp.add_resource(TextResource(
    uri="resource://notice",
    text="System maintenance scheduled for Sunday."
))

# Dynamic: function runs on each read
@mcp.resource("resource://timestamp")
def get_timestamp() -> str:
    """Returns the current server time."""
    from datetime import datetime
    return datetime.now().isoformat()
```

### The @resource Decorator

Decorate any Python function with `@mcp.resource` to expose it as a dynamic resource. FastMCP extracts metadata from your function: the URI comes from the decorator argument, the name defaults to the function name, and the description defaults to the docstring. The function only executes when a client reads the resource, not at registration time.

```python
import json
from fastmcp import FastMCP

mcp = FastMCP()

@mcp.resource("data://config")
def get_config() -> str:
    """Provides application configuration as JSON."""
    return json.dumps({
        "theme": "dark",
        "version": "1.2.0",
        "features": ["tools", "resources"],
    })
```

Override defaults or add metadata with decorator arguments:

```python
import json
from fastmcp import FastMCP

mcp = FastMCP()

@mcp.resource(
    uri="data://app-status",
    name="ApplicationStatus",
    description="Current application health and metrics.",
    mime_type="application/json",
    tags={"monitoring", "status"},
)
def get_application_status() -> str:
    """Internal docstring (ignored when description provided)."""
    return json.dumps({"status": "ok", "uptime": 12345})
```

<Card icon="code" title="@resource Decorator Arguments">
<ParamField body="uri" type="str" required>
  The unique identifier for the resource.
</ParamField>

<ParamField body="name" type="str | None">
  Human-readable name. Defaults to the function name.
</ParamField>

<ParamField body="description" type="str | None">
  Explanation of the resource. Defaults to the docstring.
</ParamField>

<ParamField body="mime_type" type="str | None">
  Content type. FastMCP infers `text/plain` or `application/json` by default, but explicit is better for binary data.
</ParamField>

<ParamField body="tags" type="set[str] | None">
  Categorization tags for filtering and organization.
</ParamField>

<ParamField body="icons" type="list[Icon] | None">
  <VersionBadge version="2.13.0" />
  Icon representations for this resource. See [Icons](/servers/icons).
</ParamField>

<ParamField body="annotations" type="Annotations | dict | None">
  MCP annotations describing resource behavior. See [Annotations](#annotations).
</ParamField>

<ParamField body="meta" type="dict[str, Any] | None">
  <VersionBadge version="2.11.0" />
  Custom metadata passed through to clients.
</ParamField>

<ParamField body="version" type="str | int | None">
  <VersionBadge version="3.0.0" />
  Version identifier. See [Versioning](/servers/versioning).
</ParamField>
</Card>

### Annotations

<VersionBadge version="2.11.0" />

Annotations communicate resource behavior to clients without consuming LLM context. Clients use these hints for caching decisions and access patterns.

```python
import json
from fastmcp import FastMCP

mcp = FastMCP()

@mcp.resource(
    "data://config",
    annotations={"readOnlyHint": True, "idempotentHint": True}
)
def get_config() -> str:
    """Get application configuration."""
    return json.dumps({"version": "1.0", "debug": False})
```

| Annotation | Type | Default | Purpose |
| :--------- | :--- | :------ | :------ |
| `readOnlyHint` | boolean | true | Resource only provides data without side effects |
| `idempotentHint` | boolean | true | Repeated reads have the same effect as one read |

Annotations are advisory hints that help clients optimize behavior but don't enforce anything server-side.

### Async Resources

FastMCP supports both `async def` and regular `def` resource functions. Synchronous functions run in a threadpool to avoid blocking the event loop. For I/O-bound operations, async functions are more efficient:

```python
import aiofiles
from fastmcp import FastMCP

mcp = FastMCP()

@mcp.resource("file:///app/data/log.txt", mime_type="text/plain")
async def read_log() -> str:
    """Reads the application log asynchronously."""
    async with aiofiles.open("/app/data/log.txt", mode="r") as f:
        return await f.read()
```

### Context Access

<VersionBadge version="2.2.5" />

Resources can access MCP context for request information and server features. Add a `Context` parameter to your function:

```python
import json
from fastmcp import FastMCP, Context

mcp = FastMCP()

@mcp.resource("resource://system-status")
async def get_system_status(ctx: Context) -> str:
    """Provides system status with request context."""
    return json.dumps({
        "status": "operational",
        "request_id": ctx.request_id
    })
```

See [Context](/servers/context) for the full Context API.

### Instance Methods

The `@mcp.resource` decorator registers resources immediately, which doesn't work with instance methods. Use the standalone `@resource` decorator to attach metadata, then register the bound method:

```python
from fastmcp import FastMCP
from fastmcp.resources import resource

class DataProvider:
    def __init__(self, prefix: str):
        self.prefix = prefix

    @resource("data://greeting")
    def get_greeting(self) -> str:
        """Get a greeting message."""
        return f"{self.prefix} Hello!"

provider = DataProvider(prefix="[INFO]")
mcp = FastMCP()
mcp.add_resource(provider.get_greeting)
```

### Removing Resources

<VersionBadge version="2.3.4" />

Remove resources dynamically with `remove_resource()`:

```python
from fastmcp import FastMCP

mcp = FastMCP()

@mcp.resource("data://temporary")
def temp_resource() -> str:
    return "This won't last"

mcp.remove_resource("data://temporary")
```

### Error Handling

<VersionBadge version="2.4.1" />

Resource functions can raise standard Python exceptions or `ResourceError` for controlled error messages.

By default, exception details are sent to clients to help LLMs understand failures. To mask internal details for security, either set `mask_error_details=True` on the server or use `ResourceError` for messages that should always be visible:

```python
from fastmcp import FastMCP
from fastmcp.exceptions import ResourceError

mcp = FastMCP(mask_error_details=True)

@mcp.resource("data://secure")
def get_secure_data() -> str:
    # This message is always sent to clients
    raise ResourceError("Access denied: invalid credentials")

@mcp.resource("data://internal")
def get_internal_data() -> str:
    # This message would be masked when mask_error_details=True
    raise ValueError("Database connection failed: host=internal.db")
```

## Templates

Use resource templates when you need one definition to serve many URIs: user profiles by ID, files by path, or any resource where the URI contains variable data.

Resource templates let clients request resources whose content depends on parameters embedded in the URI. Define a template using `@mcp.resource` with `{parameter}` placeholders that map to function arguments. A single template like `user://{id}/profile` can generate unlimited resources: `user://alice/profile`, `user://bob/profile`, and so on.

### Basic Templates

Include `{parameter_name}` placeholders in the URI string and add matching arguments to your function:

```python
import json
from fastmcp import FastMCP

mcp = FastMCP()

@mcp.resource("weather://{city}/current")
def get_weather(city: str) -> str:
    """Provides weather information for a specific city."""
    return json.dumps({
        "city": city.capitalize(),
        "temperature": 22,
        "condition": "Sunny"
    })

@mcp.resource("repos://{owner}/{repo}/info")
def get_repo_info(owner: str, repo: str) -> str:
    """Retrieves information about a GitHub repository."""
    return json.dumps({
        "owner": owner,
        "name": repo,
        "full_name": f"{owner}/{repo}"
    })
```

Clients request concrete URIs and FastMCP extracts the parameters:

- `weather://london/current` calls `get_weather(city="london")`
- `repos://jlowin/fastmcp/info` calls `get_repo_info(owner="jlowin", repo="fastmcp")`

<Tip>
Functions with `*args` are not supported as resource templates. However, `**kwargs` is supported because the URI template defines specific parameter names that get passed as keyword arguments.
</Tip>

### Wildcard Parameters

<VersionBadge version="2.2.4" />

Standard parameters (`{param}`) match a single path segment and stop at `/` boundaries. Wildcard parameters (`{param*}`) capture multiple segments including slashes, useful for file paths and hierarchical data.

```python
from fastmcp import FastMCP

mcp = FastMCP()

# Standard: matches only one segment
@mcp.resource("files://{filename}")
def get_file(filename: str) -> str:
    """Retrieves a file by name."""
    return f"File content for: {filename}"
# Matches: files://readme.txt
# Fails:   files://docs/readme.txt

# Wildcard: matches multiple segments
@mcp.resource("path://{filepath*}")
def get_path_content(filepath: str) -> str:
    """Retrieves content at a specific path."""
    return f"Content at path: {filepath}"
# Matches: path://docs/server/resources.mdx

# Mixed: wildcard stops at next literal
@mcp.resource("repo://{owner}/{path*}/template.py")
def get_template_file(owner: str, path: str) -> str:
    """Retrieves template.py from a repository path."""
    return f"Template at {path}/template.py in {owner}'s repo"
# Matches: repo://jlowin/fastmcp/src/resources/template.py
```

Wildcards capture all subsequent path segments until the next literal part of the template. Multiple wildcards in one template work because each stops at its boundary.

### Query Parameters

<VersionBadge version="2.13.0" />

FastMCP supports RFC 6570 form-style query parameters using `{?param1,param2}` syntax. Query parameters must be optional function parameters with default values, while path parameters map to required parameters.

```python
from fastmcp import FastMCP

mcp = FastMCP()

@mcp.resource("data://{id}{?format}")
def get_data(id: str, format: str = "json") -> str:
    """Retrieve data in specified format."""
    if format == "xml":
        return f"<data id='{id}' />"
    return f'{{"id": "{id}"}}'

@mcp.resource("api://{endpoint}{?version,limit,offset}")
def call_api(endpoint: str, version: int = 1, limit: int = 10, offset: int = 0) -> dict:
    """Call API endpoint with pagination."""
    return {
        "endpoint": endpoint,
        "version": version,
        "limit": limit,
        "offset": offset
    }
```

Example requests:

- `data://123` uses default `format="json"`
- `data://123?format=xml` uses `format="xml"`
- `api://users?version=2&limit=50` sets `version=2`, `limit=50`, keeps `offset=0`

FastMCP automatically coerces query parameter strings to the correct types based on your type hints.

To keep optional parameters hidden from clients (always use defaults), omit them from the URI template:

```python
from fastmcp import FastMCP

mcp = FastMCP()

# Clients CAN override max_results via query string
@mcp.resource("search://{query}{?max_results}")
def search_configurable(query: str, max_results: int = 10) -> dict:
    return {"query": query, "limit": max_results}

# Clients CANNOT override max_results (not in URI template)
@mcp.resource("search://{query}")
def search_fixed(query: str, max_results: int = 10) -> dict:
    return {"query": query, "limit": max_results}
```

### Parameter Rules

<VersionBadge version="2.2.0" />

FastMCP validates template definitions against these rules:

1. **Required function parameters** must appear in the URI path template
2. **Query parameters** must be optional function parameters with default values
3. **All URI template parameters** must exist as function parameters

Optional function parameters can be query parameters (`{?param}`) for client-configurable options, omitted from the URI to always use defaults, or used in alternative path templates for multiple access patterns.

### Multiple Templates

Create multiple resource templates that expose the same function through different URI patterns:

```python
from fastmcp import FastMCP

mcp = FastMCP()

def lookup_user(name: str | None = None, email: str | None = None) -> dict:
    """Look up a user by either name or email."""
    if email:
        return {"found_by": "email", "email": email}
    elif name:
        return {"found_by": "name", "name": name}
    return {"error": "No lookup parameters provided"}

# Register the same function with different URI patterns
mcp.resource("users://email/{email}")(lookup_user)
mcp.resource("users://name/{name}")(lookup_user)
```

Clients can now access user information two ways:

- `users://email/alice@example.com` calls `lookup_user(email="alice@example.com")`
- `users://name/Bob` calls `lookup_user(name="Bob")`

### Context in Templates

<VersionBadge version="2.2.5" />

Templates can access MCP context just like regular resources. Add a `Context` parameter alongside your template parameters:

```python
import json
from fastmcp import FastMCP, Context

mcp = FastMCP()

@mcp.resource("resource://{name}/details")
async def get_details(name: str, ctx: Context) -> str:
    """Get details for a specific name with context."""
    return json.dumps({
        "name": name,
        "request_id": ctx.request_id
    })
```

## Results

<VersionBadge version="3.0.0" />

Resource functions return content in three forms:

| Return Type | Behavior |
| :---------- | :------- |
| `str` | Sent as text content with `mime_type="text/plain"` by default |
| `bytes` | Base64 encoded as binary content. Specify an appropriate `mime_type`. |
| `ResourceResult` | Full control over content, MIME types, and metadata |

For structured data like dicts or lists, serialize to JSON with `json.dumps()`. This explicit approach ensures type errors surface during development rather than at runtime.

### ResourceResult

`ResourceResult` wraps one or more content items with optional result-level metadata:

```python
from fastmcp import FastMCP
from fastmcp.resources import ResourceResult, ResourceContent

mcp = FastMCP()

@mcp.resource("data://users")
def get_users() -> ResourceResult:
    return ResourceResult(
        contents=[
            ResourceContent(content='[{"id": 1}]', mime_type="application/json"),
            ResourceContent(content="# Users\n...", mime_type="text/markdown"),
        ],
        meta={"total": 1}
    )
```

<Card title="ResourceResult">
<ParamField body="contents" type="str | bytes | list[ResourceContent]" required>
  Content to return. Strings and bytes are wrapped in a single `ResourceContent`. Use a list for multiple items or custom MIME types.
</ParamField>
<ParamField body="meta" type="dict[str, Any] | None">
  Result-level metadata, included in the MCP response's `_meta` field.
</ParamField>
</Card>

For simple content, pass `str` or `bytes` directly:

```python
from fastmcp.resources import ResourceResult, ResourceContent

# String content
return ResourceResult("plain text")

# Binary content
return ResourceResult(b"\x00\x01\x02")

# Explicit content list
return ResourceResult(contents=[
    ResourceContent(content="item 1"),
    ResourceContent(content="item 2"),
])
```

### ResourceContent

`ResourceContent` represents a single piece of content with its MIME type and optional metadata:

```python
from fastmcp.resources import ResourceContent

# Text with explicit MIME type
ResourceContent(content='{"key": "value"}', mime_type="application/json")

# Binary with MIME type
ResourceContent(content=b"\x89PNG...", mime_type="image/png")

# With item-level metadata
ResourceContent(
    content="data",
    mime_type="text/plain",
    meta={"source": "cache", "ttl": 300}
)
```

<Card title="ResourceContent">
<ParamField body="content" type="Any" required>
  The content data. Strings and bytes pass through directly. Other types (dict, list, BaseModel) are automatically JSON-serialized.
</ParamField>
<ParamField body="mime_type" type="str | None">
  MIME type. Defaults to `text/plain` for strings, `application/octet-stream` for bytes, `application/json` for serialized objects.
</ParamField>
<ParamField body="meta" type="dict[str, Any] | None">
  Item-level metadata for this specific content.
</ParamField>
</Card>

### MIME Type Defaults

| Content Type | Default MIME Type |
| :----------- | :---------------- |
| `str` | `text/plain` |
| `bytes` | `application/octet-stream` |
| `dict`, `list`, `BaseModel` | `application/json` |

Override defaults by specifying `mime_type` explicitly:

```python
from fastmcp.resources import ResourceResult, ResourceContent

# JSON string with correct MIME type
return ResourceResult(
    contents=[ResourceContent(
        content='{"users": []}',
        mime_type="application/json"
    )]
)
```

### Multiple Content Items

A single resource can return multiple content items, useful for providing the same data in different formats:

```python
from fastmcp import FastMCP
from fastmcp.resources import ResourceResult, ResourceContent

mcp = FastMCP()

@mcp.resource("report://summary")
def get_summary() -> ResourceResult:
    data = {"total": 100, "active": 85}
    return ResourceResult(contents=[
        ResourceContent(
            content=data,
            mime_type="application/json"
        ),
        ResourceContent(
            content="Total: 100, Active: 85",
            mime_type="text/plain"
        ),
    ])
```

### Metadata Levels

`ResourceResult` supports metadata at two levels:

**Item-level metadata** in `ResourceContent.meta` applies to individual content items. Use for content-specific information like encoding, source, or processing details.

**Result-level metadata** in `ResourceResult.meta` applies to the entire response. Use for aggregate information like counts, timing, or pagination.

```python
from fastmcp.resources import ResourceResult, ResourceContent

return ResourceResult(
    contents=[
        ResourceContent(
            content="data",
            meta={"encoding": "utf-8", "cached": True}  # Item-level
        )
    ],
    meta={"request_time_ms": 45, "total_items": 1}  # Result-level
)
```

## Resource Classes

FastMCP provides built-in resource classes for common content sources. Use these when content comes directly from files, URLs, or static text rather than a computed function. Register them with `mcp.add_resource()` instead of the `@mcp.resource` decorator.

| Class | Purpose |
| :---- | :------ |
| `TextResource` | Static string content |
| `BinaryResource` | Static bytes content |
| `FileResource` | Read from local file |
| `DirectoryResource` | List directory contents |
| `HttpResource` | Fetch from HTTP URL |

### TextResource

Static text content defined at registration time:

```python
from fastmcp import FastMCP
from fastmcp.resources import TextResource

mcp = FastMCP()

mcp.add_resource(TextResource(
    uri="resource://notice",
    text="System maintenance scheduled for Sunday.",
    name="Maintenance Notice",
    description="Current system notices.",
    mime_type="text/plain",
    tags={"notification"}
))
```

<Card title="TextResource">
<ParamField body="uri" type="str" required>
  Unique resource identifier.
</ParamField>
<ParamField body="text" type="str" required>
  The text content.
</ParamField>
<ParamField body="name" type="str | None">
  Human-readable name.
</ParamField>
<ParamField body="description" type="str | None">
  Resource description.
</ParamField>
<ParamField body="mime_type" type="str">
  Content type. Defaults to `text/plain`.
</ParamField>
<ParamField body="tags" type="set[str] | None">
  Categorization tags.
</ParamField>
</Card>

### BinaryResource

Static binary content defined at registration time:

```python
from fastmcp import FastMCP
from fastmcp.resources import BinaryResource

mcp = FastMCP()

mcp.add_resource(BinaryResource(
    uri="resource://icon",
    data=b"\x89PNG\r\n\x1a\n...",
    name="App Icon",
    mime_type="image/png"
))
```

<Card title="BinaryResource">
<ParamField body="uri" type="str" required>
  Unique resource identifier.
</ParamField>
<ParamField body="data" type="bytes" required>
  The binary content.
</ParamField>
<ParamField body="name" type="str | None">
  Human-readable name.
</ParamField>
<ParamField body="description" type="str | None">
  Resource description.
</ParamField>
<ParamField body="mime_type" type="str">
  Content type. Defaults to `application/octet-stream`.
</ParamField>
<ParamField body="tags" type="set[str] | None">
  Categorization tags.
</ParamField>
</Card>

### FileResource

Reads content from a local file. Content is read lazily when the resource is accessed, and FileResource handles both text and binary files automatically based on the MIME type.

```python
from pathlib import Path
from fastmcp import FastMCP
from fastmcp.resources import FileResource

mcp = FastMCP()

readme_path = Path("./README.md").resolve()
mcp.add_resource(FileResource(
    uri=f"file://{readme_path.as_posix()}",
    path=readme_path,
    name="README",
    description="Project documentation.",
    mime_type="text/markdown",
    tags={"documentation"}
))
```

<Card title="FileResource">
<ParamField body="uri" type="str" required>
  Unique resource identifier. Use `file://` scheme for consistency.
</ParamField>
<ParamField body="path" type="Path | str" required>
  Path to the file on disk.
</ParamField>
<ParamField body="name" type="str | None">
  Human-readable name. Defaults to the filename.
</ParamField>
<ParamField body="description" type="str | None">
  Resource description.
</ParamField>
<ParamField body="mime_type" type="str | None">
  Content type. Auto-detected from file extension if not specified.
</ParamField>
<ParamField body="tags" type="set[str] | None">
  Categorization tags.
</ParamField>
</Card>

### DirectoryResource

Lists files in a local directory. Returns a JSON array of file information:

```python
from pathlib import Path
from fastmcp import FastMCP
from fastmcp.resources import DirectoryResource

mcp = FastMCP()

data_dir = Path("./app_data").resolve()
mcp.add_resource(DirectoryResource(
    uri="resource://data-files",
    path=data_dir,
    name="Data Directory",
    description="Lists available data files.",
    recursive=False
))
```

<Card title="DirectoryResource">
<ParamField body="uri" type="str" required>
  Unique resource identifier.
</ParamField>
<ParamField body="path" type="Path | str" required>
  Path to the directory on disk.
</ParamField>
<ParamField body="name" type="str | None">
  Human-readable name.
</ParamField>
<ParamField body="description" type="str | None">
  Resource description.
</ParamField>
<ParamField body="recursive" type="bool">
  Include subdirectories. Defaults to `False`.
</ParamField>
<ParamField body="tags" type="set[str] | None">
  Categorization tags.
</ParamField>
</Card>

The resource returns JSON with file metadata:

```json
[
  {"name": "data.csv", "path": "/app_data/data.csv", "size": 1024},
  {"name": "config.json", "path": "/app_data/config.json", "size": 256}
]
```

### HttpResource

Fetches content from an HTTP or HTTPS URL. Requires the `httpx` package. Content is fetched on each access; for caching or authentication, consider using a dynamic resource with `@mcp.resource` and an HTTP client with more control.

```python
from fastmcp import FastMCP
from fastmcp.resources import HttpResource

mcp = FastMCP()

mcp.add_resource(HttpResource(
    uri="http://api.example.com/data",
    url="https://api.example.com/data",
    name="External Data",
    description="Data from external API.",
    mime_type="application/json"
))
```

<Card title="HttpResource">
<ParamField body="uri" type="str" required>
  Unique resource identifier exposed to clients.
</ParamField>
<ParamField body="url" type="str" required>
  The HTTP(S) URL to fetch.
</ParamField>
<ParamField body="name" type="str | None">
  Human-readable name.
</ParamField>
<ParamField body="description" type="str | None">
  Resource description.
</ParamField>
<ParamField body="mime_type" type="str | None">
  Content type. Uses response Content-Type header if not specified.
</ParamField>
<ParamField body="tags" type="set[str] | None">
  Categorization tags.
</ParamField>
</Card>

### Custom Keys

<VersionBadge version="2.2.0" />

When adding resources with `mcp.add_resource()`, you can provide a custom storage key different from the URI. Custom keys affect how the resource is stored and accessed internally but don't change the URI exposed to clients.

```python
from fastmcp import FastMCP
from fastmcp.resources import TextResource

mcp = FastMCP()

resource = TextResource(uri="resource://data", text="content")

# Standard: key matches URI
mcp.add_resource(resource)  # key = "resource://data"

# Custom: different internal key
mcp.add_resource(resource, key="internal://data-v2")
```

## Server Behavior

### Visibility Control

<VersionBadge version="3.0.0" />

Control which resources are visible to clients using server-level visibility control. Disabled resources don't appear in `list_resources` and can't be read.

```python
from fastmcp import FastMCP

mcp = FastMCP()

@mcp.resource("data://public", tags={"public"})
def get_public(): return "public"

@mcp.resource("data://secret", tags={"internal"})
def get_secret(): return "secret"

# Disable specific resources by key
mcp.disable(keys=["resource:data://secret"])

# Disable resources by tag
mcp.disable(tags={"internal"})

# Or use allowlist mode - only show resources with specific tags
mcp.enable(tags={"public"}, only=True)
```

See [Local Provider](/servers/providers/local#visibility-control) for the complete visibility control API.

### Notifications

<VersionBadge version="2.9.1" />

FastMCP automatically sends `notifications/resources/list_changed` notifications to connected clients when resources or templates are added, enabled, or disabled. This allows clients to stay up-to-date with the current resource set without manually polling for changes.

Notifications are only sent when these operations occur within an active MCP request context (e.g., when called from within a tool or other MCP operation). Operations performed during server initialization do not trigger notifications.

### Duplicates

<VersionBadge version="2.1.0" />

Configure how the server handles attempts to register multiple resources with the same URI using the `on_duplicate_resources` setting:

```python
from fastmcp import FastMCP

mcp = FastMCP(on_duplicate_resources="error")

@mcp.resource("data://config")
def get_config_v1(): return {"version": 1}

# This raises ValueError because "data://config" is already registered
# @mcp.resource("data://config")
# def get_config_v2(): return {"version": 2}
```

Options:

- `"warn"` (default): Logs a warning, new resource replaces the old one
- `"error"`: Raises `ValueError`, preventing duplicate registration
- `"replace"`: Silently replaces the existing resource
- `"ignore"`: Keeps the original resource, ignores the new one

### Versioning

<VersionBadge version="3.0.0" />

Resources and resource templates support versioning, allowing you to maintain multiple implementations under the same URI while clients automatically receive the highest version. See [Versioning](/servers/versioning) for complete documentation.
